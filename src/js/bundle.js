(()=>{"use strict";const t=Math.PI/180,e=115,i=["Grass","Ground","Sandstone"],s=["Rect","Square"],r=[101,50],a=[50,50],n=[[4,2],[5.5,2.5],[7,3]],o=[.55,.7,.85],h=3e-4,c=[76,81,77,64,81,81,76,69],l=[49,62,49,41,69,56,48,41],_=[20,25,20,15,25,25,25,20],u=[43,50,36,36,29,36,43,29],d=[36,36,22,36,29,29,36,29],p=[47,49,40,43,50,36,43,36],g=[14,10,14,7,11,16,14,14],m=[],T=[],M=[4,10,0,0,4,4,0,0,0];class S{get width(){return this._width}get height(){return this._height}get sprite(){return this._sprite}constructor(t,e){this._width=t,this._height=e,this._sprite=new Image(t,e),this._sprite.classList.add("sprite")}setPosition(t){this._sprite.style.left=`${t.x}px`,this._sprite.style.top=`${t.y}px`}setAngle(t){this._sprite.style.transform=`rotate(${t}rad)`}}class A extends S{constructor(t){var s,r;super(e,e),this._sprite.src=`src/img/backgrounds/${i[t]}_${s=0,r=1,Math.floor(Math.random()*(r+1-s))+s}.png`,this._sprite.style.zIndex="1"}}class f{constructor(t,e){this._x=t,this._y=e}get x(){return this._x}set x(t){this._x=t}get y(){return this._y}set y(t){this._y=t}clone(){return new f(this._x,this._y)}addToCoordinates(t,e){this._x+=t,this._y+=e}}class k extends f{get length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){const t=this.length;this._x/=t,this._y/=t}get angle(){return Math.atan2(this.y,this.x)}clone(){return new k(this.x,this.y)}addVector(t){this._x+=t._x,this._y+=t._y}scale(t){this._x*=t,this._y*=t}}class y extends k{constructor(t,e){super(t,e)}static create(t,e){const i=new y(t.y-e.y,e.x-t.x);return i.normalize(),i}clone(){return new y(this._x,this._y)}}class P{constructor(){}static fullFillBackground(t,i,s,r){for(let a=0;a<i;a+=e)for(let i=0;i<s;i+=e)r.push(this.addBackgroundTile(new f(a,i),t))}static addBackgroundTile(t,e){const i=new A(e);return i.setPosition(t),i}}class C{constructor(){}static dotProduct(t,e){return t.x*e.x+t.y*e.y}static crossProduct(t,e){return t.x*e.y-t.y*e.x}static add(t,e){return new k(t.x+e.x,t.y+e.y)}static subtract(t,e){return new k(t.x-e.x,t.y-e.y)}static scale(t,e){return new k(t.x*e,t.y*e)}}class v{constructor(){}static add(t,e){return new f(t.x+e.x,t.y+e.y)}static subtract(t,e){return new f(t.x-e.x,t.y-e.y)}static scale(t,e){return new f(t.x*e,t.y*e)}}class w{constructor(){}static hasCollision(t,e){const i=[...w.getAxes(t),...w.getAxes(e)];for(const s of i){const i=w.getProject(t,s),r=w.getProject(e,s);if(Math.min(i.max-r.min,r.max-i.min)<=0)return!1}return!0}static getCollisionResult(t,e){const i=[...w.getAxes(t),...w.getAxes(e)];let s,r=Number.MAX_VALUE;for(const a of i){const i=w.getProject(t,a),n=w.getProject(e,a),o=Math.min(i.max-n.min,n.max-i.min);if(o<=0)return null;o<r&&(r=o,s=a)}return{collisionPoint:w.findClosestVertex(t,e,s),overlap:r}}static findClosestVertex(t,e,i){let s=Number.MAX_VALUE,r=new f(0,0);function a(t,e){for(const a of e){const e=Math.abs(C.dotProduct(v.subtract(a,t),i));Math.abs(e-s)<w.EPSILON?r=new f((r.x+a.x)/2,(r.y+a.y)/2):e<s&&(s=e,r=a)}}return a(t.calcCenter(),e.points),a(e.calcCenter(),t.points),r}static getAxes(t){const e=new Array,i=t.points.length-1;for(let s=0;s<i;s++)e.push(y.create(t.points[s],t.points[s+1]));return e.push(y.create(t.points[i],t.points[0])),e}static getProject(t,e){let i=C.dotProduct(e,t.points[0]),s=i;for(let r=1;r<t.points.length;r++){const a=C.dotProduct(e,t.points[r]);a<i?i=a:a>s&&(s=a)}return{min:i,max:s}}}function E(t,e){const i=e.x-t.x,s=e.y-t.y;return Math.sqrt(i*i+s*s)}function I(t,e=0,i=2*Math.PI){for(;t<e;)t+=i-e;for(;t>=i;)t-=i-e;return t}function L(t){return t>Math.PI/2&&t<3*Math.PI/2}function x(t,e){return I(t-e)}w.EPSILON=1;class D{constructor(){}static resolveCollision(t,e){const i=w.getCollisionResult(t,e);if(null===i)return;const s=this.calcCollisionNormal(i.collisionPoint,t.calcCenter()),r=this.calsImpulseMagnitude(t,e,s);this.separateEntities(t,i.overlap,s),this.updateAngularVelocity(t,e,i.collisionPoint,r,s),this.updateVelocity(t,e,r,s)}static updateAngularVelocity(t,e,i,s,r){const a=this.calcEntityNormal(t),n=C.subtract(i,e.calcCenter()),o=C.subtract(i,t.calcCenter()),h=C.crossProduct(n,r)*s,c=C.crossProduct(o,a)*s,l=h/e.momentOfInertia;let _=c/t.momentOfInertia;this.shouldReverseReceiving(e.angle,a.angle)&&(_=-_),Math.abs(_+t.angularVelocity)<this.SMALL_ANGULAR_IMPULSE&&Math.abs(_)>this.ORTHOGONAL_IMPULSE&&(_=1===Math.sign(_)?this.SMALL_ANGULAR_IMPULSE:-this.SMALL_ANGULAR_IMPULSE),e.angularVelocity+=l,t.angularVelocity+=_}static shouldReverseReceiving(t,e){const i=I(t-e,0,Math.PI);return i<Math.PI/2&&i>Math.PI/4||i>=Math.PI/2&&i<3*Math.PI/4}static calcEntityNormal(t){const e=t.angle;return L(x(e,t.velocity.angle))?new k(-Math.cos(e),-Math.sin(e)):new k(Math.cos(e),Math.sin(e))}static updateVelocity(t,e,i,s){const r=C.scale(s,-i/t.mass),a=C.scale(s,i/e.mass);t.velocity.addVector(r),e.velocity.addVector(a)}static separateEntities(t,e,i){let s=-i.x*e,r=-i.y*e;s+=1===Math.sign(s)?this.CORRECTION_FACTOR:-this.CORRECTION_FACTOR,r+=1===Math.sign(r)?this.CORRECTION_FACTOR:-this.CORRECTION_FACTOR;for(const e of t.points)e.addToCoordinates(s,r)}static calsImpulseMagnitude(t,e,i){const s=C.subtract(t.velocity,e.velocity);return 2*C.dotProduct(s,i)/(1/t.mass+1/e.mass)*this.COEFFICIENT_OF_RESTITUTION}static calcCollisionNormal(t,e){const i=C.subtract(t,e);return i.normalize(),i}}D.COEFFICIENT_OF_RESTITUTION=.6,D.CORRECTION_FACTOR=.55,D.SMALL_ANGULAR_IMPULSE=.004,D.ORTHOGONAL_IMPULSE=1e-4;class N{constructor(){}static isTank(t){return t>=N.STARTING_TANK_ID&&t<=N.ENDING_TANK_ID}static isWall(t){return t>=N.STARTING_WALL_ID&&t<=N.ENDING_WALL_ID}static isBullet(t){return t>=N.STARTING_BULLET_ID&&t<=N.ENDING_BULLET_ID}static get tankId(){if(N.TANK_ID>N.ENDING_TANK_ID)throw new Error("Maximum tank ID is reached");return N.TANK_ID++}static get wallId(){if(N.WALL_ID>N.ENDING_WALL_ID)throw new Error("Maximum wall ID is reached");return N.WALL_ID++}static get bulletId(){return N.BULLET_ID>N.ENDING_BULLET_ID&&(N.BULLET_ID=N.STARTING_BULLET_ID),N.BULLET_ID++}}N.STARTING_TANK_ID=0,N.ENDING_TANK_ID=N.STARTING_TANK_ID+42424242424242,N.STARTING_WALL_ID=N.ENDING_TANK_ID+1,N.ENDING_WALL_ID=N.STARTING_WALL_ID+42424242424242,N.STARTING_BULLET_ID=N.ENDING_WALL_ID+1,N.ENDING_BULLET_ID=N.STARTING_BULLET_ID+42424242424242,N.TANK_ID=N.STARTING_TANK_ID,N.WALL_ID=N.STARTING_WALL_ID,N.BULLET_ID=N.STARTING_BULLET_ID;class R{constructor(){this._idForProcessing=new Array}hasForProcessing(){return 0!==this._idForProcessing.length}clear(){this._idForProcessing.length=0}push(t){this._idForProcessing.push(t)}get iterable(){return this._idForProcessing}}class F{get wallsForProcessing(){return this._wallsForProcessing}constructor(t){this._wallsForProcessing=new R,this._collisionDetection=t}hasCollision(t){const e=this._collisionDetection.getCollisions(t);let i=!1;for(const s of e)D.resolveCollision(t,s),this.processCollision(s),i=!0;return i?e:null}processCollision(t){N.isWall(t.id)&&this._wallsForProcessing.push(t.id)}}class O{constructor(t,e,i){this._canvas=t,this._width=e,this._height=i}get canvas(){return this._canvas}get width(){return this._width}get height(){return this._height}}class b{constructor(t,e,i,s){this._root=new U({xStart:t,yStart:e,xLast:i,yLast:s},null)}insert(t){this._root.insert(t)}getCollisions(t){return this._root.getCollisions(t)}remove(t){this._root.remove(t)}clear(){this._root=null}}class U{constructor(t,e){this._entities=new Set,this._children=null,this._boundary=t,this._parent=e}isSubdivide(){return null===this._entities}subdivide(){const t=this._boundary.xStart,e=this._boundary.yStart,i=this._boundary.xLast,s=this._boundary.yLast,r=(i-t)/2,a=(s-e)/2;this._children=[new U({xStart:t,yStart:e,xLast:t+r,yLast:e+a},this),new U({xStart:t+r,yStart:e,xLast:i,yLast:e+a},this),new U({xStart:t,yStart:e+a,xLast:t+r,yLast:s},this),new U({xStart:t+r,yStart:e+a,xLast:i,yLast:s},this)],this.redistribute()}redistribute(){for(const t of this._entities)for(const e of this._children)e.isContainsEntity(t)&&e.insert(t);this._entities=null}insert(t){if(this.isSubdivide())for(const e of this._children)e.isContainsEntity(t)&&e.insert(t);else this._entities.add(t),this._entities.size>U.CAPACITY&&this.subdivide()}remove(t){if(this.isSubdivide()){for(const e of this._children)e.isContainsEntity(t)&&e.remove(t);this.mergeCheck()}else this._entities.delete(t),null!==this._parent&&this._parent.mergeCheck()}getCollisions(t){const e=new Array;if(this.isSubdivide())for(const i of this._children)i.isContainsEntity(t)&&e.push(...i.getCollisions(t));else for(const i of this._entities)w.hasCollision(t,i)&&e.push(i);return e}isContainsEntity(t){for(const e of t.points)if(this.isContainsPoint(e))return!0;return!1}isContainsPoint(t){return t.x>this._boundary.xStart&&t.x<this._boundary.xLast&&t.y>this._boundary.yStart&&t.y<this._boundary.yLast}mergeCheck(){let t=0;for(const e of this._children)t+=e.getEntitiesCount();t<=U.HALF_CAPACITY&&this.mergeWithChildren()}mergeWithChildren(){this._entities=new Set;for(const t of this._children){t.isSubdivide()&&t.mergeWithChildren();for(const e of t._entities)this._entities.add(e)}this._children=null}getEntitiesCount(){if(this.isSubdivide()){let t=0;for(const e of this._children)t+=e.getEntitiesCount();return t}return this._entities.size}}U.CAPACITY=8,U.HALF_CAPACITY=U.CAPACITY>>1;class H{set resistanceCoeff(t){this._resistanceCoeff=t}set airResistanceCoeff(t){this._airResistanceCoeff=t}constructor(t,e){this._resistanceCoeff=0,this._airResistanceCoeff=0,this._entityStorage=t,this._collisionManager=e}get entityStorage(){return this._entityStorage}get collisionManager(){return this._collisionManager}}class K extends H{residualMovement(t){const e=t.sprite;t.model.isIdle()?(e.tankTrackEffect.stopped(),e.tankTrackEffect.stopped()):(e.tankTrackEffect.setResidualMovement(),e.tankTrackEffect.setResidualMovement(),this.hullUpdate(t,t.model.residualMovement,t.sprite.preUpdateAction))}residualAngularMovement(t){t.model.isAngularMotionStopped()||this.hullUpdate(t,t.model.residualAngularMovement,t.sprite.preUpdateAction)}turretCounterclockwiseMovement(t){t.model.turretCounterclockwiseMovement(),K.turretUpdate(t)}turretClockwiseMovement(t){t.model.turretClockwiseMovement(),K.turretUpdate(t)}hullCounterclockwiseMovement(t){this.hullUpdate(t,t.model.hullCounterclockwiseMovement,t.sprite.preUpdateAction)}hullClockwiseMovement(t){this.hullUpdate(t,t.model.hullClockwiseMovement,t.sprite.preUpdateAction)}forwardMovement(t){this.hullUpdate(t,t.model.forwardMovement,t.sprite.updateForwardAction)}backwardMovement(t){this.hullUpdate(t,t.model.backwardMovement,t.sprite.updateBackwardAction)}hullUpdate(t,e,i){const s=t.model.entity;this._entityStorage.remove(s),e.call(t.model,this._resistanceCoeff,this._airResistanceCoeff),this._collisionManager.hasCollision(s)&&t.sprite.removeAcceleration(),i.call(t.sprite,s.points[0],s.angle,t.model.tankParts.turret.angle),this._entityStorage.insert(s)}static turretUpdate(t){const e=t.model,i=e.entity.angle,s=Math.sin(i),r=Math.cos(i);t.sprite.rotateTurretUpdate(t.sprite.tankSpriteParts.hullSprite.calcPosition(e.entity.points[0],s,r),e.tankParts.turret.angle,s,r)}}class W{constructor(){this._keysMask=0,document.addEventListener("keydown",this.handleKeyDown.bind(this)),document.addEventListener("keyup",this.handleKeyUp.bind(this))}clearMask(){this._keysMask=0}get keysMask(){return this._keysMask}handleKeyDown(t){this._keysMask|=W.getMask(t.keyCode)}handleKeyUp(t){this._keysMask&=~W.getMask(t.keyCode)}static getMask(t){switch(t){case 65:return W.A_MASK;case 66:return W.B_MASK;case 67:return W.C_MASK;case 68:return W.D_MASK;case 69:return W.E_MASK;case 70:return W.F_MASK;case 71:return W.G_MASK;case 72:return W.H_MASK;case 73:return W.I_MASK;case 74:return W.J_MASK;case 75:return W.K_MASK;case 76:return W.L_MASK;case 77:return W.M_MASK;case 78:return W.N_MASK;case 79:return W.O_MASK;case 80:return W.P_MASK;case 81:return W.Q_MASK;case 82:return W.R_MASK;case 83:return W.S_MASK;case 84:return W.T_MASK;case 85:return W.U_MASK;case 86:return W.V_MASK;case 87:return W.W_MASK;case 88:return W.X_MASK;case 89:return W.Y_MASK;case 191:return W.SLASH_MASK;case 190:return W.PERIOD_MASK;case 188:return W.COMMA_MASK;case 38:return W.UP_MASK;case 40:return W.DOWN_MASK;case 37:return W.LEFT_MASK;case 39:return W.RIGHT_MASK;default:return 0}}}W.A_MASK=1,W.B_MASK=2,W.C_MASK=4,W.D_MASK=8,W.E_MASK=16,W.F_MASK=32,W.G_MASK=64,W.H_MASK=128,W.I_MASK=256,W.J_MASK=512,W.K_MASK=1024,W.L_MASK=2048,W.M_MASK=4096,W.N_MASK=8192,W.O_MASK=16384,W.P_MASK=32768,W.Q_MASK=65536,W.R_MASK=1<<17,W.S_MASK=1<<18,W.T_MASK=1<<19,W.U_MASK=1<<20,W.V_MASK=1<<21,W.W_MASK=1<<22,W.X_MASK=1<<23,W.Y_MASK=1<<24,W.SLASH_MASK=1<<25,W.PERIOD_MASK=1<<26,W.COMMA_MASK=1<<27,W.UP_MASK=1<<28,W.DOWN_MASK=1<<29,W.RIGHT_MASK=1<<30,W.LEFT_MASK=1<<31;class G{constructor(){}static rotatePointAroundTarget(t,e,i,s){const r=t.x-e.x,a=t.y-e.y;t.x=e.x+r*s-a*i,t.y=e.y+r*i+a*s}static rotatePoint(t,e,i){const s=t.x,r=t.y;t.x=s*i-r*e,t.y=s*e+r*i}}class V{constructor(){}static movement(t){for(const e of t.points)e.addToCoordinates(t.velocity.x,t.velocity.y)}static angularMovement(t){V.rotateEntity(t,t.angularVelocity)}static rotateEntity(t,e){const i=Math.sin(e),s=Math.cos(e),r=t.calcCenter();for(const e of t.points)G.rotatePointAroundTarget(e,r,i,s);G.rotatePoint(t.velocity,i,s)}}class B{constructor(t,e,i,s,r,a){this._angularVelocity=0,this._velocity=new k(0,0);const n=e*e+i*i;this._radiusLength=.5*Math.sqrt(n),this._momentOfInertia=1/12*r*n*3.75,this._mass=r,this._id=a,this._points=[t.clone(),new f(t.x+e,t.y),new f(t.x+e,t.y+i),new f(t.x,t.y+i)],0!==s&&V.rotateEntity(this,s)}get velocity(){return this._velocity}get angle(){return Math.atan2(this._points[1].y-this._points[0].y,this._points[1].x-this._points[0].x)}get points(){return this._points}get mass(){return this._mass}get angularVelocity(){return this._angularVelocity}set angularVelocity(t){this._angularVelocity=t}get id(){return this._id}get radiusLength(){return this._radiusLength}get momentOfInertia(){return this._momentOfInertia}calcCenter(){return new f((this._points[0].x+this._points[2].x)/2,(this._points[0].y+this._points[2].y)/2)}}class ${constructor(t,e){this._model=t,this._sprite=e,this._id=t.entity.id}get model(){return this._model}get sprite(){return this._sprite}get id(){return this._id}spawn(t,e){t.appendChild(this._sprite.sprite),e.insert(this._model.entity)}}class X{constructor(){}static rotateToDefaultSpritePoint(t,e,i,s){const r=t.width>>1,a=t.height>>1;G.rotatePointAroundTarget(e,new f(e.x+r*s-a*i,e.y+a*s+r*i),-i,s)}static rotateToActualSpritePoint(t,e,i,s){const r=t.width>>1,a=t.height>>1;G.rotatePointAroundTarget(e,new f(e.x+r,e.y+a),i,s)}static updateSpritePart(t,e,i,s,r){X.rotateToDefaultSpritePoint(t,e,i,s),X.setPosAndAngle(t,e,r)}static setPosAndAngle(t,e,i){t.setPosition(e),t.setAngle(i)}static rotateForTurretPoint(t,e,i,s,r,a){const n=t.width>>1,o=t.height>>1;G.rotatePointAroundTarget(e,new f(e.x+n*s-o*i,e.y+o*s+n*i),r*s-a*i,s*a+i*r)}}class Y extends S{constructor(t,e){super(r[e],a[e]),this._sprite.src=`src/img/blocks/${i[t]}_${s[e]}.png`,this._sprite.style.zIndex="2"}updateAfterAction(t,e){t=t.clone(),X.rotateToDefaultSpritePoint(this,t,Math.sin(e),Math.cos(e)),X.setPosAndAngle(this,t,e)}}class z{constructor(t){this._entity=t}get entity(){return this._entity}isIdle(){return 0===this._entity.velocity.length}isAngularMotionStopped(){return 0===this._entity.angularVelocity}residualMovement(t,e){const i=this._entity,s=this.calcAcceleration(0,t,e,i.velocity.length),r=i.velocity.angle;this.applyVelocityChange(s,r),V.movement(i)}residualAngularMovement(t,e){const i=this._entity,s=this.calcAcceleration(0,t,e,i.angularVelocity)/i.radiusLength,r=i.angularVelocity;r>0?i.angularVelocity+=r+s<0?-r:s:i.angularVelocity-=r+s>0?-r:s,V.angularMovement(i)}calcAcceleration(t,e,i,s){return(t-e*this._entity.mass*.01-i*s*s)/this._entity.mass}applyVelocityChange(t,e){const i=this._entity,s=Math.sign(i.velocity.x),r=Math.sign(i.velocity.y);i.velocity.addToCoordinates(t*Math.cos(e),t*Math.sin(e)),s!==Math.sign(i.velocity.x)&&(i.velocity.x=0),r!==Math.sign(i.velocity.y)&&(i.velocity.y=0)}}class j extends z{constructor(t){super(t),this._health=1/0}takeDamage(t){this._health-=t.damage}get health(){return this._health}}class Q{constructor(){}static createWallsAroundPerimeter(t,e,i){const s=new Array,r=this.calcIndent(e),n=this.calcIndent(i-(a[this.RECT_NUM]<<1));return this.createHorWalls(t,r,n,e,i,s),this.createVertWalls(t,r,n,e,i,s),s}static calcIndent(t){const e=t-(this.INDENT<<1);return(e-r[this.RECT_NUM]*Math.floor(e/r[this.RECT_NUM])>>1)+this.INDENT}static createHorWalls(t,e,i,s,n,o){for(let h=e;h<=s-e-r[this.RECT_NUM];h+=r[this.RECT_NUM])o.push(this.createWall(new f(h,i),0,t,this.RECT_NUM)),o.push(this.createWall(new f(h,n-a[this.RECT_NUM]-i),0,t,this.RECT_NUM))}static createVertWalls(t,e,i,s,n,o){for(let h=i+a[this.RECT_NUM]+(a[this.RECT_NUM]>>1);h<=n-i-r[this.RECT_NUM];h+=r[this.RECT_NUM])o.push(this.createWall(new f(e-(a[this.RECT_NUM]>>1),h),this.RAD_90,t,this.RECT_NUM)),o.push(this.createWall(new f(s-e-r[this.RECT_NUM]+(a[this.RECT_NUM]>>1),h),this.RAD_90,t,this.RECT_NUM))}static createWall(t,e,i,s,o=!1){const h=o?n[i][s]:1/0,c=new j(new B(t,r[s],a[s],e,h,N.wallId)),l=new Y(i,s);return l.setPosition(t),l.setAngle(e),new $(c,l)}}Q.INDENT=10,Q.RAD_90=90*Math.PI/180,Q.RECT_NUM=0;class q extends H{residualAngularMovement(t){t.model.isAngularMotionStopped()||this.update(t,t.model.residualAngularMovement)}residualMovement(t){t.model.isIdle()||this.update(t,t.model.residualMovement)}update(t,e){const i=t.model.entity;this._entityStorage.remove(i),e.call(t.model,this._resistanceCoeff,this._airResistanceCoeff),this._collisionManager.hasCollision(i),t.sprite.updateAfterAction(i.points[0],i.angle),this._entityStorage.insert(i)}hasAnyResidualMovement(t){return!t.model.isAngularMotionStopped()||!t.model.isIdle()}movement(t){this.residualAngularMovement(t),this.residualMovement(t)}}class Z{constructor(t,e){this._elements=new Map,this._movementManager=t,this._field=e}get movementManager(){return this._movementManager}add(t){for(const e of t)this._elements.has(e.id)||(this._elements.set(e.id,e),e.spawn(this._field.canvas,this._movementManager.entityStorage))}}class J{get value(){return this._value}get prev(){return this._prev}get next(){return this._next}set next(t){this._next=t}set prev(t){this._prev=t}constructor(t){this._prev=null,this._next=null,this._value=t}remove(){null!==this._prev&&(this._prev.next=this._next),null!==this._next&&(this._next.prev=this._prev),this._prev=null,this._next=null}}class tt{constructor(){this._tail=null,this._head=null,this._length=0}get head(){return null!==this._head?this._head.value:null}get tail(){return null!==this._tail?this._tail.value:null}get length(){return this._length}*[Symbol.iterator](){let t=this._head;for(let e=this._length;e>0;e--)yield t.value,t=t.next}applyAndRemove(t,e){let i=this._head;for(;null!==i;)if(t(i.value),e(i.value))i=i.next;else{const t=i;i=i.next,this.removeNode(t)}}isEmpty(){return 0===this._length}remove(t){let e=this._head;for(;null!==e;){if(e.value===t)return void this.removeNode(e);e=e.next}}removeNode(t){t===this._tail&&(this._tail=t.prev),t===this._head&&(this._head=t.next),this._length--,t.remove()}addToHead(t){const e=new J(t);null===this._head?(this._tail=e,this._head=e):(e.next=this._head,this._head.prev=e,this._head=e),this._length++}addToTail(t){const e=new J(t);null===this._tail?(this._tail=e,this._head=e):(e.prev=this._tail,this._tail.next=e,this._tail=e),this._length++}removeFromTail(){this._tail===this._head?this.clear():(this._tail=this._tail.prev,this._tail.next=null,this._length--)}removeFromHead(){this._tail===this._head?this.clear():(this._head=this._head.next,this._head.prev=null,this._length--)}moveToTail(t){let e=this._tail;for(;null!==e;){if(e.value===t){if(e!==this._tail){const t=e.prev,i=e.next;null!==t&&(t.next=i),null!==i&&(i.prev=t),e.next=null,e.prev=this._tail,this._tail.next=e,this._tail=e}return}e=e.prev}}moveToHead(t){let e=this._head;for(;null!==e;){if(e.value===t){if(e!==this._head){const t=e.prev,i=e.next;null!==t&&(t.next=i),null!==i&&(i.prev=t),e.next=this._head,e.prev=null,this._head.prev=e,this._head=e}return}e=e.next}}clear(){this._tail=this._head=null,this._length=0}}class et{constructor(){this._vanishingListOfTirePairs=new tt,this.tanksAmount=0}get vanishingListOfTirePairs(){return this.tanksAmount++,this._vanishingListOfTirePairs}removeTireTrackPair(t){t.topTire.removeSprite(),t.bottomTire.removeSprite()}reduceOpacity(){let t=0;for(const e of this._vanishingListOfTirePairs){const i=this._vanishingListOfTirePairs.length*et.MIN_REDUCING_OPACITY_NUMBER/this.tanksAmount;e.topTire.reduceOpacity(i),e.topTire.setOpacity(),e.bottomTire.reduceOpacity(i),e.bottomTire.setOpacity(),e.topTire.isVanished()&&t++}for(;t>0;t--)this.removeTireTrackPair(this._vanishingListOfTirePairs.tail),this._vanishingListOfTirePairs.removeFromTail()}}et.MIN_REDUCING_OPACITY_NUMBER=1e-4;class it extends Z{constructor(){super(...arguments),this._tireTracksManager=new et}handle(t){this._tireTracksManager.reduceOpacity();for(const e of this._elements.values()){const i=e.control;let s=0!=(t&i.turretClockwiseMask),r=0!=(t&i.turretCounterClockwiseMask);(s&&!r||!s&&r)&&(s?this._movementManager.turretClockwiseMovement(e):r&&this._movementManager.turretCounterclockwiseMovement(e)),s=0!=(t&i.forwardMask),r=0!=(t&i.backwardMask),s&&!r||!s&&r?s?this._movementManager.forwardMovement(e):r&&(e.sprite.removeAcceleration(),this._movementManager.backwardMovement(e)):(e.sprite.removeAcceleration(),this._movementManager.residualMovement(e)),s=0!=(t&i.hullClockwiseMask),r=0!=(t&i.hullCounterClockwiseMask),s&&!r||!s&&r?s?this._movementManager.hullClockwiseMovement(e):r&&this._movementManager.hullCounterclockwiseMovement(e):this._movementManager.residualAngularMovement(e)}}add(t){super.add(t);for(const e of t){const t=e.sprite,i=e.model.entity;t.spawnTireTracks(this._field.canvas,i.points[0],i.angle,this._tireTracksManager.vanishingListOfTirePairs);const s=t.tankSpriteParts.hullSprite;t.spawnTankAcceleration(this._field.canvas,s.accelerationEffectIndentX,s.height)}}}class st extends Z{constructor(){super(...arguments),this._wallToProcess=new tt}addToProcess(){const t=this._movementManager.collisionManager.wallsForProcessing;if(t.hasForProcessing()){for(const e of t.iterable)this._wallToProcess.addToTail(this._elements.get(e));t.clear()}}handle(){this.addToProcess(),this._wallToProcess.isEmpty()||this._wallToProcess.applyAndRemove(this._movementManager.movement.bind(this._movementManager),this._movementManager.hasAnyResidualMovement.bind(this._movementManager))}}class rt{constructor(){this._animationList=new tt}add(t){this._animationList.addToTail(t)}handle(){this._animationList.isEmpty()||this._animationList.applyAndRemove((t=>t.changeStage()),(t=>!t.isEnded))}}class at{get motionData(){return this._motionData}get damage(){return this._damage}get armorPenetration(){return this._armorPenetration}get mass(){return this._mass}get health(){return this._health}takeDamage(t){this._health-=t._damage}launchFromWeapon(t){this._motionData.force*=t.forceCoeff,this._motionData.finishSpeed*=t.finishSpeedCoeff,this._damage*=t.damageCoeff,this._armorPenetration*=t.armorPenetrationCoeff}}class nt extends at{constructor(){super(...arguments),this._motionData={force:1,finishSpeed:20},this._armorPenetration=5,this._damage=15,this._mass=15e-7,this._health=1}}class ot extends z{constructor(t,e){super(e),this._bullet=t}get bullet(){return this._bullet}takeDamage(t){this._bullet.takeDamage(t)}get health(){return this._bullet.health}}class ht{constructor(){}static create(t,e,i){const s=ht.createBullet(t);return new ot(s,new B(e,m[t],T[t],i,s.mass,N.bulletId))}static createBullet(t){if(0===t)return new nt;throw new Error(`Bullet model ${t} was not found`)}}class ct extends z{constructor(t,e){super(e),this._bulletQuantity=0,this._bulletNum=0,this._isBraking=!1,this._isDrift=!1,this._tankParts=t,this._lastTimeShot=Date.now()}takeDamage(t){this._tankParts.hull.takeDamage(t)}get tankParts(){return this._tankParts}get isDrift(){return this._isDrift}get health(){return this._tankParts.hull.health}get armor(){return this._tankParts.hull.armor}get armorStrength(){return this._tankParts.hull.armorStrength}shot(){const t=Date.now();if(0===this._bulletQuantity||t-this._lastTimeShot<this._tankParts.weapon.reloadSpeed)return null;const e=ht.create(this._bulletNum,this.calcBulletExit(),this._tankParts.turret.angle);return e.bullet.launchFromWeapon(this._tankParts.weapon),this._lastTimeShot=t,this._bulletQuantity--,e}calcBulletExit(){const t=this._entity.calcCenter(),e=this._tankParts.turret.width/2+this._tankParts.weapon.barrelLength,i=t.x+e*Math.cos(this._tankParts.turret.angle),s=t.y+e*Math.sin(this._tankParts.turret.angle);return new f(i,s)}incBulletQuantity(t){this._bulletQuantity=Math.min(this._bulletQuantity+t,this._tankParts.turret.bulletCapacity)}takeNewBullet(t){this._bulletNum=t}turretClockwiseMovement(){this._tankParts.turret.clockwiseMovement()}turretCounterclockwiseMovement(){this._tankParts.turret.counterclockwiseMovement()}hullClockwiseMovement(t,e){const i=this._entity,s=this._tankParts.track.angularData;i.angularVelocity<s.finishSpeed&&(i.angularVelocity+=this.calcAcceleration(s.force,t,e,i.angularVelocity)/i.radiusLength),this.updateAngularVelocity(),V.angularMovement(i),this._tankParts.turret.incAngle(i.angularVelocity)}hullCounterclockwiseMovement(t,e){const i=this._entity,s=this._tankParts.track.angularData;-i.angularVelocity<s.finishSpeed&&(i.angularVelocity-=this.calcAcceleration(s.force,t,e,i.angularVelocity)/i.radiusLength),this.updateAngularVelocity(),V.angularMovement(i),this._tankParts.turret.incAngle(i.angularVelocity)}updateAngularVelocity(){if(this.isIdle())return;const t=this._entity,e=t.velocity;(this._isDrift||this._isBraking)&&this.incAngularVelocity(t,e),this._isBraking||this.decAngularVelocity(t,e)}incAngularVelocity(t,e){const i=this.calcCoeff(),s=1+e.length/(this._tankParts.track.forwardData.finishSpeed*i),r=1+t.mass/(10*i);t.angularVelocity*=r*s}calcCoeff(){let t=100;return this._isDrift&&(t-=25),this._isBraking&&(t-=5),t}decAngularVelocity(t,e){const i=1-e.length/(20*this._tankParts.track.forwardData.finishSpeed),s=1-t.mass/200;t.angularVelocity*=s*i,e.scale(s)}forwardMovement(t,e){this.movement(this._tankParts.track.forwardData,this._entity.angle,t,e)}backwardMovement(t,e){this.movement(this._tankParts.track.backwardData,this._entity.angle+Math.PI,t,e)}movement(t,e,i,s){const r=this._entity,a=r.velocity.length,n=0===a?e:r.velocity.angle,o=x(e,n);this.setBrakingStatus(o),ct.isStraightMovement(o)?(this._isDrift=!1,this.handleStraightMovement(t,i,s,a,n)):(this._isDrift=!ct.isReverseMovement(o),this._isDrift&&(this.determineDribbleSpeed(o),this.applyTurn(this.calcShortestTurn(o))),this.handleDriftMovement(t,i,s,a,o,n)),V.movement(r)}setBrakingStatus(t){this._isBraking=L(t)}calcShortestTurn(t){return this._isBraking&&(t=ct.adjustTurnForBraking(t)),t=ct.adjustTurnForRecovery(t)}static isStraightMovement(e){return e<=t||2*Math.PI-e<=t}static isReverseMovement(e){return Math.abs(e-Math.PI)<=t}handleStraightMovement(t,e,i,s,r){if(s<t.finishSpeed){const a=this.calcAcceleration(t.force,e,i,s);this._entity.velocity.addToCoordinates(a*Math.cos(r),a*Math.sin(r))}}handleDriftMovement(t,e,i,s,r,a){if(this._isBraking||s<t.finishSpeed){const n=this.calcAcceleration(t.force*Math.cos(r),e,i,s);this.applyVelocityChange(n,a)}}static adjustTurnForBraking(t){return I(t-Math.PI/2)}static adjustTurnForRecovery(t){const e=t-2*Math.PI;return t>Math.abs(e)?e:t}applyTurn(t){t*=ct.VELOCITY_RECOVERY_COEFF*this._entity.mass,G.rotatePoint(this._entity.velocity,Math.sin(t),Math.cos(t))}determineDribbleSpeed(t){const e=(Math.abs(Math.cos(t))-(i=0))/(1-i)*(1-(s=.95))+s;var i,s;this._entity.velocity.scale(e)}residualMovement(t,e){const i=x(this._entity.angle,this._entity.velocity.angle);(this._isDrift||!ct.isStraightMovement(i)&&!ct.isReverseMovement(i))&&(this._isDrift=!0,this.determineDribbleSpeed(i)),this._isBraking=!1,super.residualMovement(t,e)}residualAngularMovement(t,e){this.updateAngularVelocity(),super.residualAngularMovement(t,e),this._tankParts.turret.incAngle(this._entity.angularVelocity)}}ct.VELOCITY_RECOVERY_COEFF=.017;class lt extends S{constructor(t,e,i){super(t,e),this._opacity=1,this._sprite.src=`src/img/tanks/Effects/Tire Tracks/Tire_Track_Chain_${i}.png`,this._sprite.style.zIndex="3"}isVanished(){return this._opacity<=0}reduceOpacity(t){this._opacity-=t}setOpacity(){this._sprite.style.opacity=`${this._opacity}`}removeSprite(){this._sprite.remove()}}class _t extends S{constructor(t,e,i){super(t,e),this._opacity=1,this._sprite.src=`src/img/tanks/Effects/Tire Tracks/Tire_Track_${i}.png`,this._sprite.style.zIndex="3"}isVanished(){return this._opacity<=0}reduceOpacity(t){this._opacity-=t}setOpacity(){this._sprite.style.opacity=`${this._opacity}`}removeSprite(){this._sprite.remove()}}class ut{get chainWidth(){return this._chainWidth}constructor(t,e,i){this._listOfTirePairs=new tt,this._vanishingListOfTirePairs=i,this._canvas=t,this._trackWidth=e.width,this._trackHeight=e.height,this._trackType=e.num,this._chainWidth=this.calcWidthOfChain(),this._chainHeight=e.height,this._chainType=e.num%2}calcWidthOfChain(){return this._trackWidth/ut.AMOUNT_OF_CHAINS}static calcPositionOfFirstChain(t,e,i,s,r){return new f(t.x+e*r-i*r,t.y+e*s-i*s)}moveToNextChain(t,e,i){t.x=t.x-this._chainWidth*i,t.y=t.y-this._chainWidth*e}vanishFullTrack(){for(const t of this._listOfTirePairs)this._vanishingListOfTirePairs.addToHead(this._listOfTirePairs.head),this._listOfTirePairs.removeFromHead()}static setAndPosTireTrackPair(t,e,i,s,r,a){const n=e.clone(),o=i.clone();X.rotateToDefaultSpritePoint(t.topTire,n,r,a),X.rotateToDefaultSpritePoint(t.bottomTire,o,r,a),X.setPosAndAngle(t.topTire,n,s),X.setPosAndAngle(t.bottomTire,o,s)}createTireTrackChainPair(t,e,i,s,r){const a={topTire:new lt(this._chainWidth,this._chainHeight,this._chainType),bottomTire:new lt(this._chainWidth,this._chainHeight,this._chainType)};return this._canvas.appendChild(a.topTire.sprite),this._canvas.appendChild(a.bottomTire.sprite),ut.setAndPosTireTrackPair(a,t,e,i,s,r),a}createTireTrackPair(t,e,i,s,r){this.vanishFullTrack();const a={topTire:new _t(this._trackWidth,this._trackHeight,this._trackType),bottomTire:new _t(this._trackWidth,this._trackHeight,this._trackType)};this._canvas.appendChild(a.topTire.sprite),this._canvas.appendChild(a.bottomTire.sprite),ut.setAndPosTireTrackPair(a,t,e,i,s,r),this._listOfTirePairs.addToHead(a)}calcFirstTopBottomChainPoints(t,e,i,s){const r=ut.calcPositionOfFirstChain(e,this._trackWidth,this.chainWidth,i,s),a=t.hullSprite.calcPosition(e,i,s);let n=t.bottomTrackSprite.calcPosition(a,i,s);return n=ut.calcPositionOfFirstChain(n,this._trackWidth,this.chainWidth,i,s),{topFirstChainPoint:r,bottomFirstChainPoint:n}}calcLastTopBottomChainPoints(t,e,i,s){const r=e.clone(),a=t.hullSprite.calcPosition(e,i,s);return{topLastChainPoint:r,bottomLastChainPoint:t.bottomTrackSprite.calcPosition(a,i,s)}}spawnFullTireTrack(t,e,i,s,r){this._topFirstChainPoint=t.clone(),this._bottomFirstChainPoint=e.clone();for(let a=0;a<ut.AMOUNT_OF_CHAINS;a++){const n=this.createTireTrackChainPair(t,e,i,s,r);this._listOfTirePairs.addToHead(n),a===ut.AMOUNT_OF_CHAINS-1&&(this._topLastChainPoint=t.clone(),this._bottomLastChainPoint=e.clone()),this.moveToNextChain(t,s,r),this.moveToNextChain(e,s,r)}}updateAllChainPoints(t,e,i,s){this._topFirstChainPoint=t,this._bottomFirstChainPoint=e,this._topLastChainPoint=i,this._bottomLastChainPoint=s}checkForUpdate(t,e,i,s){const r=E(t,this._topFirstChainPoint),a=E(e,this._bottomFirstChainPoint),n=E(i,this._topLastChainPoint),o=E(s,this._bottomLastChainPoint);return r>=this._chainWidth?{isUpdate:!0,prevPoint:this._topFirstChainPoint,currPoint:t}:a>=this._chainWidth?{isUpdate:!0,prevPoint:this._bottomFirstChainPoint,currPoint:e}:n>=this._chainWidth?{isUpdate:!0,prevPoint:this._topLastChainPoint,currPoint:i}:o>=this._chainWidth?{isUpdate:!0,prevPoint:this._bottomLastChainPoint,currPoint:s}:{isUpdate:!1}}getMovementAngle(t,e){const i=e.x-t.x,s=e.y-t.y;return Math.atan2(s,i)}detectMovementDirection(t,e,i){const s=this.getMovementAngle(t,e);let r=I(i-ut.DIRECTION_ANGLE_DIFFERENCE,-Math.PI,Math.PI),a=I(i+ut.DIRECTION_ANGLE_DIFFERENCE,-Math.PI,Math.PI),n=!1;if(r>=Math.PI/2&&r<=Math.PI&&a>=-Math.PI&&a<=-Math.PI/2&&(n=!0,s>=0?a=I(a,0,2*Math.PI):r=I(r,-2*Math.PI,0)),s>=r&&s<=a||s<=r&&s>=a)return 1;{n&&(r<0?(r=I(r,0,2*Math.PI),a=I(a,0,2*Math.PI)):(r=I(r,-2*Math.PI,0),a=I(a,-2*Math.PI,0)));const t=I(s-Math.PI,-Math.PI,Math.PI);return t>=r&&t<=a||t<=r&&t>=a?-1:0}}forwardUpdate(t,e,i,s,r){const a=this.createTireTrackChainPair(t,e,i,s,r);this._listOfTirePairs.addToTail(a),this._listOfTirePairs.length>ut.AMOUNT_OF_CHAINS&&(this._vanishingListOfTirePairs.addToHead(this._listOfTirePairs.head),this._listOfTirePairs.removeFromHead())}backwardUpdate(t,e,i,s,r){const a=this.createTireTrackChainPair(t,e,i,s,r);this._listOfTirePairs.addToHead(a),this._listOfTirePairs.length>ut.AMOUNT_OF_CHAINS&&(this._vanishingListOfTirePairs.addToHead(this._listOfTirePairs.tail),this._listOfTirePairs.removeFromTail())}}var dt;ut.DIRECTION_ANGLE_DIFFERENCE=.6,ut.AMOUNT_OF_CHAINS=10;class pt extends S{constructor(){super(pt.SIZE,pt.SIZE),this._sprite.style.zIndex="5",this._sprite.src=pt.SRC[0]}setSrc(t){this._sprite.src=pt.SRC[t]}}dt=pt,pt.DEFAULT_SRC="src/img/tanks/Effects/Movement/Movement_",pt.SRC=[`${dt.DEFAULT_SRC}0.png`,`${dt.DEFAULT_SRC}1.png`,`${dt.DEFAULT_SRC}2.png`,`${dt.DEFAULT_SRC}3.png`,`${dt.DEFAULT_SRC}4.png`,`${dt.DEFAULT_SRC}5.png`,`${dt.DEFAULT_SRC}6.png`,`${dt.DEFAULT_SRC}7.png`,`${dt.DEFAULT_SRC}8.png`,`${dt.DEFAULT_SRC}9.png`,`${dt.DEFAULT_SRC}10.png`,`${dt.DEFAULT_SRC}11.png`,`${dt.DEFAULT_SRC}12.png`,`${dt.DEFAULT_SRC}13.png`,`${dt.DEFAULT_SRC}14.png`,`${dt.DEFAULT_SRC}15.png`,`${dt.DEFAULT_SRC}16.png`,`${dt.DEFAULT_SRC}17.png`,`${dt.DEFAULT_SRC}18.png`,`${dt.DEFAULT_SRC}19.png`],pt.SIZE=85;class gt{constructor(t,e,i){this._topSpriteAccelerationEffect=new pt,this._bottomSpriteAccelerationEffect=new pt,this._counter=0,this._state=0,this._canvas=t,this._indentX=e,this._tankHeight=i}changeState(){this._state===gt.LAST_STATE&&(this._state=gt.WORKING_STATE),this._counter++,this._counter===gt.THRESHOLD&&(this._counter=0,this._state++,this._topSpriteAccelerationEffect.setSrc(this._state),this._bottomSpriteAccelerationEffect.setSrc(this._state))}setPosition(t,e,i,s){0===this._state&&0===this._counter&&(this._canvas.appendChild(this._topSpriteAccelerationEffect.sprite),this._canvas.appendChild(this._bottomSpriteAccelerationEffect.sprite)),this.changeState();let r=this.calcPosition(t,e,i,28*this._tankHeight/42);X.updateSpritePart(this._topSpriteAccelerationEffect,r,e,i,s),r=this.calcPosition(t,e,i,37*this._tankHeight/42),X.updateSpritePart(this._bottomSpriteAccelerationEffect,r,e,i,s)}removeAcceleration(){if(0===this._state&&0===this._counter)return;this._state=0,this._counter=0;const t=this._topSpriteAccelerationEffect,e=this._bottomSpriteAccelerationEffect;t.setSrc(this._state),e.setSrc(this._state),t.sprite.remove(),e.sprite.remove()}calcPosition(t,e,i,s){return new f(t.x+this._indentX*i-s*e-pt.SIZE/2*i+pt.SIZE/1.517*e,t.y+s*i+this._indentX*e-pt.SIZE/1.517*i-pt.SIZE/2*e)}}gt.THRESHOLD=7,gt.LAST_STATE=19,gt.WORKING_STATE=10;class mt{constructor(t,e){this._state=0,this._counter=0,this._isForwardMovement=!0,this._isResidualMovement=!1,this._minStateChangeThreshold=[Math.max(Math.round(mt.MIN_THRESHOLD_COEFF/e.finishSpeed),mt.MIN_STATE_CHANGE_THRESHOLD_MINIMUM),Math.max(Math.round(mt.MIN_THRESHOLD_COEFF/t.finishSpeed),mt.MIN_STATE_CHANGE_THRESHOLD_MINIMUM)],this._maxStateChangeThreshold=[Math.min(Math.round(mt.MAX_THRESHOLD_COEFF/e.force),mt.MAX_STATE_CHANGE_THRESHOLD_MAXIMUM),Math.min(Math.round(mt.MAX_THRESHOLD_COEFF/t.force),mt.MAX_STATE_CHANGE_THRESHOLD_MAXIMUM)],this._currentThreshold=this._maxStateChangeThreshold[this._isForwardMovement?1:0]}set isForwardMovement(t){this._isResidualMovement=!1,this._isForwardMovement!==t&&(this._isForwardMovement=t,this._currentThreshold=this._maxStateChangeThreshold[this._isForwardMovement?1:0])}setResidualMovement(){this._isResidualMovement=!0}changeState(t,e){this._counter++,this._counter>=this._currentThreshold&&(this._counter=0,this._state^=1,t.setSrc(this._state),e.setSrc(this._state),this._isResidualMovement?this._currentThreshold<this._maxStateChangeThreshold[this._isForwardMovement?1:0]&&this._currentThreshold++:this._currentThreshold>this._minStateChangeThreshold[this._isForwardMovement?1:0]&&this._currentThreshold--)}stopped(){this._currentThreshold=this._maxStateChangeThreshold[this._isForwardMovement?1:0]}}mt.MIN_THRESHOLD_COEFF=17.5,mt.MAX_THRESHOLD_COEFF=.5,mt.MIN_STATE_CHANGE_THRESHOLD_MINIMUM=2,mt.MAX_STATE_CHANGE_THRESHOLD_MAXIMUM=30;class Tt{constructor(t,e,i){this._tankSpriteParts=t,this._tankTrackEffect=new mt(e,i)}get tankSpriteParts(){return this._tankSpriteParts}get tankTrackEffect(){return this._tankTrackEffect}spawnTankAcceleration(t,e,i){this._tankAcceleration=new gt(t,e,i)}removeAcceleration(){this._tankAcceleration.removeAcceleration()}spawnTireTracks(t,e,i,s){this._tankTireTrack=new ut(t,this._tankSpriteParts.topTrackSprite,s);const r=Math.sin(i),a=Math.cos(i),{topFirstChainPoint:n,bottomFirstChainPoint:o}=this._tankTireTrack.calcFirstTopBottomChainPoints(this._tankSpriteParts,e,r,a);this._tankTireTrack.spawnFullTireTrack(n,o,i,r,a)}updateTireTrack(t,e,i,s){const{topFirstChainPoint:r,bottomFirstChainPoint:a}=this._tankTireTrack.calcFirstTopBottomChainPoints(this._tankSpriteParts,t,i,s),{topLastChainPoint:n,bottomLastChainPoint:o}=this._tankTireTrack.calcLastTopBottomChainPoints(this._tankSpriteParts,t,i,s),{isUpdate:h,prevPoint:c,currPoint:l}=this._tankTireTrack.checkForUpdate(r,a,n,o);if(h){this._tankTireTrack.updateAllChainPoints(r,a,n,o);switch(this._tankTireTrack.detectMovementDirection(c,l,e)){case 1:this._tankTireTrack.forwardUpdate(r,a,e,i,s);break;case 0:this._tankTireTrack.createTireTrackPair(n,o,e,i,s);break;case-1:this._tankTireTrack.backwardUpdate(n,o,e,i,s)}}}updateForwardAction(t,e,i){this._tankTrackEffect.isForwardMovement=!0;const s=Math.sin(e),r=Math.cos(e),a=this._tankSpriteParts.hullSprite.calcPosition(t,s,r);this.updateSprite(t,e,i,s,r,a),this._tankAcceleration.setPosition(a,s,r,e),this.updateTireTrack(t,e,s,r)}updateBackwardAction(t,e,i){this._tankTrackEffect.isForwardMovement=!1;const s=Math.sin(e),r=Math.cos(e);this.defaultUpdate(t,e,i,s,r),this.updateTireTrack(t,e,s,r)}preUpdateAction(t,e,i){const s=Math.sin(e),r=Math.cos(e);this.updateTireTrack(t,e,s,r),this.defaultUpdate(t,e,i,s,r)}updateAfterAction(t,e,i){const s=Math.sin(e),r=Math.cos(e);this.defaultUpdate(t,e,i,s,r)}defaultUpdate(t,e,i,s,r){const a=this._tankSpriteParts.hullSprite.calcPosition(t,s,r);this.updateSprite(t,e,i,s,r,a)}rotateTurretUpdate(t,e,i,s){const r=Math.sin(e),a=Math.cos(e),n=this._tankSpriteParts.turretSprite,o=n.calcPosition(t,i,s),h=o.clone();X.rotateForTurretPoint(n,h,i,s,r,a),X.rotateToDefaultSpritePoint(n,o,i,s),X.setPosAndAngle(n,o,e);let c=this._tankSpriteParts.weaponSprite.calcPosition(h,r,a);X.updateSpritePart(this._tankSpriteParts.weaponSprite,c,r,a,e)}updateSprite(t,e,i,s,r,a){const n=this._tankSpriteParts.topTrackSprite,o=this._tankSpriteParts.bottomTrackSprite,h=this._tankSpriteParts.hullSprite;let c=n.calcPosition(t);X.updateSpritePart(n,c,s,r,e),c=h.calcPosition(t,s,r),X.updateSpritePart(h,c,s,r,e),c=o.calcPosition(a,s,r),X.updateSpritePart(o,c,s,r,e),this.rotateTurretUpdate(a,i,s,r),this._tankTrackEffect.changeState(n,o)}}class Mt{get health(){return this._health}get armor(){return this._armor}get mass(){return this._mass}get armorStrength(){return this._armorStrength}takeDamage(t){this._armorStrength-=t.armorPenetration,this._health-=t.damage-this._armor*Math.max(this._armorStrength,0)}}class St extends Mt{constructor(){super(...arguments),this._mass=1,this._armor=100,this._health=100,this._armorStrength=1}}class At{constructor(){this._angularData={finishSpeed:.0175,force:.03},this._forwardData={finishSpeed:3,force:.03},this._backwardData={finishSpeed:2,force:.025}}get angularData(){return this._angularData}get forwardData(){return this._forwardData}get backwardData(){return this._backwardData}}class ft{get angle(){return this._angle}constructor(t){this._angle=t}incAngle(t){this._angle+=t}}class kt extends ft{get bulletCapacity(){return 10}get mass(){return.35}clockwiseMovement(){this._angle+=kt.ANGLE_SPEED}counterclockwiseMovement(){this._angle-=kt.ANGLE_SPEED}get width(){return u[0]}}kt.ANGLE_SPEED=.0125;class yt{get barrelLength(){return g[0]}get armorPenetrationCoeff(){return 1}get damageCoeff(){return 1}get forceCoeff(){return 1}get finishSpeedCoeff(){return 1}get reloadSpeed(){return 3e3}get mass(){return.15}}class Pt{constructor(t,e,i,s){this._hull=t,this._track=e,this._turret=i,this._weapon=s}get hull(){return this._hull}get track(){return this._track}get turret(){return this._turret}get weapon(){return this._weapon}}class Ct{constructor(){}static create(t,e,i,s,r){const a=Ct.createTurret(s,t),n=Ct.createWeapon(r),o=Ct.createHull(e),h=Ct.createTrack(i);return new Pt(o,h,a,n)}static createHull(t){if(0===t)return new St;throw new Error(`Hull model ${t} was not found`)}static createTrack(t){if(0===t)return new At;throw new Error(`Track model ${t} was not found`)}static createTurret(t,e){if(0===t)return new kt(e);throw new Error(`Turret model ${t} was not found`)}static createWeapon(t){if(0===t)return new yt;throw new Error(`Weapon model ${t} was not found`)}}class vt extends S{get accelerationEffectIndentX(){return this._accelerationEffectIndentX}constructor(t,e){super(c[e],l[e]),this._accelerationEffectIndentX=M[e],this._sprite.src=`src/img/tanks/Hulls/Hull_${e}/Hull_${t}.png`,this._sprite.style.zIndex="5"}calcPosition(t,e,i){return new f(t.x-5*e,t.y+5*i)}}class wt extends S{static calcHeight(t){return wt.PROPORTION_WIDTH_HEIGHT*t}get num(){return this._num}constructor(t,e,i){super(e+5,i),this._num=t,this._srcState0=`src/img/tanks/Tracks/Track_${t}_A.png`,this._srcState1=`src/img/tanks/Tracks/Track_${t}_B.png`,this._sprite.style.zIndex="4",this._sprite.src=this._srcState0}setSrc(t){this._sprite.src=0===t?this._srcState0:this._srcState1}}wt.PROPORTION_WIDTH_HEIGHT=42/246;class Et extends wt{constructor(t,e){super(t,e,wt.calcHeight(e))}calcPosition(t){return t.clone()}}class It extends wt{constructor(t,e,i){const s=wt.calcHeight(e);super(t,e,s),this._deltaHeight=i+5-s}calcPosition(t,e,i){return new f(t.x-this._deltaHeight*e,t.y+this._deltaHeight*i)}}class Lt extends S{constructor(t,e,i,s){super(u[e],d[e]),this._sprite.src=`src/img/tanks/Turrets/Turret_${e}/Turret_${t}.png`,this._sprite.style.zIndex="6",this._indentX=i,this._indentY=s}calcPosition(t,e,i){return new f(t.x+this._indentX*i-this._indentY*e,t.y+this._indentY*i+this._indentX*e)}}class xt extends S{constructor(t,e,i){super(p[t],g[t]),this._sprite.src=`src/img/tanks/Weapons/Weapon_${t}.png`,this._sprite.style.zIndex="6",this._indentX=e,this._indentY=i}calcPosition(t,e,i){return new f(t.x+this._indentX*i-this._indentY*e,t.y+this._indentY*i+this._indentX*e)}}class Dt{constructor(t,e,i,s,r){this._hullSprite=t,this._bottomTrackSprite=e,this._topTrackSprite=i,this._turretSprite=s,this._weaponSprite=r}get hullSprite(){return this._hullSprite}get bottomTrackSprite(){return this._bottomTrackSprite}get topTrackSprite(){return this._topTrackSprite}get turretSprite(){return this._turretSprite}get weaponSprite(){return this._weaponSprite}}class Nt{constructor(){}static create(t,e,i,s,r){return new Dt(new vt(t,e),new It(i,c[e],l[e]),new Et(i,c[e]),new Lt(t,s,_[e],(l[e]>>1)-(d[s]>>1)),new xt(r,u[s],(d[s]>>1)-(g[r]>>1)))}}class Rt{get model(){return this._model}get sprite(){return this._sprite}get id(){return this._id}get control(){return this._control}set control(t){this._control=t}constructor(t,e,i,s,r,a,n,o){this._control=o;const h=Ct.create(e,s,r,a,n),_=new B(t,c[s]+5,l[s]+10,e,h.turret.mass+h.hull.mass+h.weapon.mass,N.tankId);this._model=new ct(h,_),this._id=_.id;const u=h.track;this._sprite=new Tt(Nt.create(i,s,r,a,n),u.forwardData,u.backwardData)}spawn(t,e){const i=this._sprite.tankSpriteParts;t.appendChild(i.topTrackSprite.sprite),t.appendChild(i.bottomTrackSprite.sprite),t.appendChild(i.hullSprite.sprite),t.appendChild(i.weaponSprite.sprite),t.appendChild(i.turretSprite.sprite);const s=this._model.entity;e.insert(s),this._sprite.updateAfterAction(s.points[0],s.angle,this._model.tankParts.turret.angle)}}window.onmousedown=t=>console.log(`x = ${t.clientX}px, y = ${t.clientY}px`);const Ft=document.querySelector("#canvas"),Ot=new class{constructor(t,e,i){this._isGameLoopActive=!1,this._backgroundSprites=new Array,this._animationManager=new rt,this._field=new O(t,e,i),this._keyHandler=new W;const s=new b(0,0,e,i),r=new F(s);this._tankHandlingManagers=new it(new K(s,r),this._field),this._wallHandlingManagers=new st(new q(s,r),this._field)}createField(t,e){this.setCoefficients(t),this.createBackgroundSprites(t),this.createWalls(e)}setCoefficients(t){this._tankHandlingManagers.movementManager.resistanceCoeff=o[t],this._tankHandlingManagers.movementManager.airResistanceCoeff=h,this._wallHandlingManagers.movementManager.resistanceCoeff=o[t],this._wallHandlingManagers.movementManager.airResistanceCoeff=h}createBackgroundSprites(t){P.fullFillBackground(t,this._field.width,this._field.height,this._backgroundSprites);for(const t of this._backgroundSprites)this._field.canvas.appendChild(t.sprite)}createWalls(t){const e=this._field.width,i=this._field.height;this._wallHandlingManagers.add(Q.createWallsAroundPerimeter(t,e,i));const s=new Array;s.push(Q.createWall(new f(e>>1,i>>1),.79,2,0,!0)),s.push(Q.createWall(new f(e>>2,i>>2),1,2,1,!0)),this._wallHandlingManagers.add(s)}addTankElements(...t){this._tankHandlingManagers.add(t)}startGameLoop(){this._isGameLoopActive||(this._isGameLoopActive=!0,this._keyHandler.clearMask(),requestAnimationFrame((()=>this.gameLoop())))}stopGameLoop(){this._isGameLoopActive=!1}gameLoop(){this._isGameLoopActive&&(this._tankHandlingManagers.handle(this._keyHandler.keysMask),this._wallHandlingManagers.handle(),this._animationManager.handle(),requestAnimationFrame((()=>this.gameLoop())))}}(Ft,window.screen.width,window.screen.height);Ot.createField(1,2);const bt={forwardMask:W.W_MASK,backwardMask:W.S_MASK,hullClockwiseMask:W.D_MASK,hullCounterClockwiseMask:W.A_MASK,turretClockwiseMask:W.V_MASK,turretCounterClockwiseMask:W.C_MASK,shoot:W.B_MASK},Ut=new Rt(new f(300,300),0,0,0,0,0,0,bt),Ht={forwardMask:W.UP_MASK,backwardMask:W.DOWN_MASK,hullClockwiseMask:W.RIGHT_MASK,hullCounterClockwiseMask:W.LEFT_MASK,turretClockwiseMask:W.PERIOD_MASK,turretCounterClockwiseMask:W.COMMA_MASK,shoot:W.SLASH_MASK},Kt=new Rt(new f(450,450),0,1,0,0,0,0,Ht);Ot.addTankElements(Ut,Kt),Ot.startGameLoop()})();