(()=>{"use strict";class t{static get BACKGROUND_SIZE(){return t.fieldsX.BACKGROUND_SIZE}static get WALL_WIDTH(){return t.fieldsX.WALL_WIDTH}static get WALL_HEIGHT(){return t.fieldsY.WALL_HEIGHT}static get TRACK_INDENT(){return t.fieldsY.TRACK_INDENT}static get HULL_WIDTH(){return t.fieldsX.HULL_WIDTH}static get HULL_HEIGHT(){return t.fieldsY.HULL_HEIGHT}static get TURRET_INDENT_X(){return t.fieldsX.TURRET_INDENT_X}static get TURRET_WIDTH(){return t.fieldsX.TURRET_WIDTH}static get TURRET_HEIGHT(){return t.fieldsY.TURRET_HEIGHT}static get WEAPON_WIDTH(){return t.fieldsX.WEAPON_WIDTH}static get WEAPON_HEIGHT(){return t.fieldsY.WEAPON_HEIGHT}static get BULLET_WIDTH(){return t.fieldsX.BULLET_WIDTH}static get BULLET_HEIGHT(){return t.fieldsY.BULLET_HEIGHT}static get ACCELERATION_SIZE(){return t.fieldsX.ACCELERATION_SIZE}static get EXPLOSION_SIZE(){return t.fieldsX.EXPLOSION_SIZE}static get ACCELERATION_EFFECT_INDENT_X(){return t.fieldsX.ACCELERATION_EFFECT_INDENT_X}static get KEY_SIZE(){return t.fieldsX.KEY_SIZE}static get BOX_SIZE(){return t.fieldsX.BOX_SIZE}static get HEALTH_BAR_HEIGHT(){return t.fieldsY.HEALTH_BAR_HEIGHT}static get ARMOR_BAR_HEIGHT(){return t.fieldsY.ARMOR_BAR_HEIGHT}static get HEALTH_ARMOR_BAR_INDENT_Y(){return t.fieldsY.HEALTH_ARMOR_BAR_INDENT_Y}static resizeX(e){return Math.round(e*t.resizeWidthCoeff)}static resizeY(e){return Math.round(e*t.resizeHeightCoeff)}static undoResizeX(e){return Math.round(e/t.resizeWidthCoeff)}static undoResizeY(e){return Math.round(e/t.resizeHeightCoeff)}static setResolutionResizeCoeff(e,i){t.resizeWidthCoeff=e/t.DEVELOPING_SCREEN_WIDTH,t.resizeHeightCoeff=i/t.DEVELOPING_SCREEN_HEIGHT,t.resizeConstants()}static resizeConstants(){for(const e in t.fieldsX){const i=t.fieldsX[e];t.fieldsX[e]=Array.isArray(i)?i.map(t.resizeX):t.resizeX(i)}for(const e in t.fieldsY){const i=t.fieldsY[e];t.fieldsY[e]=Array.isArray(i)?i.map(t.resizeY):t.resizeY(i)}}}t.resizeWidthCoeff=1,t.resizeHeightCoeff=1,t.DEVELOPING_SCREEN_WIDTH=1920,t.DEVELOPING_SCREEN_HEIGHT=1080,t.fieldsX={BACKGROUND_SIZE:115,WALL_WIDTH:[110,55],HULL_WIDTH:[63,67,64,53,67,67,63,57],TURRET_INDENT_X:[17,21,17,12,21,21,21,17],TURRET_WIDTH:[35,42,30,30,24,30,35,24],WEAPON_WIDTH:[39,41,33,35,42,30,35,30],BULLET_WIDTH:[13,18,25,26,21],ACCELERATION_SIZE:70,EXPLOSION_SIZE:99,ACCELERATION_EFFECT_INDENT_X:[4,11,0,0,4,4,0,0,0],KEY_SIZE:55,BOX_SIZE:55},t.fieldsY={WALL_HEIGHT:[55,55],TRACK_INDENT:5,HULL_HEIGHT:[41,52,41,34,57,46,40,34],TURRET_HEIGHT:[30,30,19,30,24,24,30,24],WEAPON_HEIGHT:[12,9,12,6,9,13,12,12],BULLET_HEIGHT:[6,9,11,7,9],HEALTH_BAR_HEIGHT:10,ARMOR_BAR_HEIGHT:4,HEALTH_ARMOR_BAR_INDENT_Y:3};const e=Math.PI/180,i=["Grass","Ground","Sandstone"],s=["Rect","Square"],r=[[4,2],[5.5,2.5],[7,3]],n=[.55,.7,.85];var a;!function(t){t[t.bulLight=0]="bulLight",t[t.bulMedium=1]="bulMedium",t[t.bulHeavy=2]="bulHeavy",t[t.bulGrenade=3]="bulGrenade",t[t.bulSniper=4]="bulSniper",t[t.kill=5]="kill",t[t.key=6]="key"}(a||(a={}));class o{constructor(t,e){this._x=t,this._y=e}get x(){return this._x}set x(t){this._x=t}get y(){return this._y}set y(t){this._y=t}clone(){return new o(this._x,this._y)}addToCoordinates(t,e){this._x+=t,this._y+=e}}class l extends o{get length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){const t=this.length;0!==t&&(this._x/=t,this._y/=t)}get angle(){return Math.atan2(this.y,this.x)}clone(){return new l(this.x,this.y)}addVector(t){this._x+=t._x,this._y+=t._y}subtractVector(t){this._x-=t._x,this._y-=t._y}scale(t){this._x*=t,this._y*=t}}class h extends l{constructor(t,e){super(t,e)}static create(t,e){const i=new h(t.y-e.y,e.x-t.x);return i.normalize(),i}clone(){return new h(this._x,this._y)}}class c{get startingSpeed(){return 35}get damage(){return 15}get armorPenetration(){return.1}get mass(){return.008}get health(){return 1}get num(){return 0}}class _{constructor(){}static calcAcceleration(t,e,i,s,r,n,a){return(t-e*n*.01-i*r*r*a)/n*(s/17)}static calcAngularAcceleration(t,e,i,s,r,n,a,o){return this.calcAcceleration(t,e,i,s,r,n,a)/o}}class u{constructor(){}static calcAcceleration(t,e,i,s,r,n){return(t-e*s*s*n)/r*(i/17)}static calcAngularAcceleration(t,e,i,s,r,n,a){return this.calcAcceleration(t,e,i,s,r,n)/a}}class d{constructor(t,e){this._entity=t,this._health=e}get health(){return this._health}isDead(){return this._health<=0}get entity(){return this._entity}isIdle(){return 0===this._entity.velocity.length}isAngularMotionStopped(){return 0===this._entity.angularVelocity}applyVelocityChange(t,e){const i=this._entity,s=Math.sign(i.velocity.x),r=Math.sign(i.velocity.y);i.velocity.addToCoordinates(t*Math.cos(e),t*Math.sin(e)),s!==Math.sign(i.velocity.x)&&(i.velocity.x=0),r!==Math.sign(i.velocity.y)&&(i.velocity.y=0)}applyAngularVelocityChange(t){const e=this._entity,i=e.angularVelocity;i>0?e.angularVelocity+=i+t<0?-i:t:e.angularVelocity-=i+t>0?-i:t}takeDamage(t){this._health-=t.damage}}class m extends d{residualMovement(t,e,i){const s=this._entity,r=_.calcAcceleration(0,t,e,i,s.velocity.length,s.mass,s.lengthwiseArea);this.applyVelocityChange(r,s.velocity.angle)}residualAngularMovement(t,e,i){const s=this._entity,r=_.calcAngularAcceleration(0,t,e,i,s.angularVelocity,s.mass,s.lengthwiseArea,s.radiusLength);this.applyAngularVelocityChange(r)}}class g extends d{residualMovement(t,e){const i=this._entity,s=u.calcAcceleration(0,t,e,i.velocity.length,i.mass,i.lengthwiseArea);this.applyVelocityChange(s,i.velocity.angle)}residualAngularMovement(t,e){const i=this._entity,s=u.calcAngularAcceleration(0,t,e,i.angularVelocity,i.mass,i.lengthwiseArea,i.radiusLength);this.applyAngularVelocityChange(s)}}class I extends g{constructor(t,e,i){super(e,t.health),this._damage=t.damage*i.damageCoeff,this._armorPenetration=t.armorPenetration*i.armorPenetrationCoeff,this._maxHealth=t.health}get maxHealth(){return this._maxHealth}get damage(){return this._damage}get armorPenetration(){return this._armorPenetration}}class p{constructor(){}static rotatePointAroundTarget(t,e,i,s){const r=t.x-e.x,n=t.y-e.y;t.x=e.x+r*s-n*i,t.y=e.y+r*i+n*s}static rotatePoint(t,e,i){const s=t.x,r=t.y;t.x=s*i-r*e,t.y=s*e+r*i}}class E{constructor(){}static movement(t){for(const e of t.points)e.addToCoordinates(t.velocity.x,t.velocity.y)}static angularMovement(t){E.rotateEntity(t,t.angularVelocity)}static rotateEntity(t,e){const i=Math.sin(e),s=Math.cos(e),r=t.calcCenter();for(const e of t.points)p.rotatePointAroundTarget(e,r,i,s);p.rotatePoint(t.velocity,i,s)}}function T(t,e){const i=e.x-t.x,s=e.y-t.y;return Math.sqrt(i*i+s*s)}function L(t,e=0,i=2*Math.PI){for(;t<e;)t+=i-e;for(;t>=i;)t-=i-e;return t}function M(t){return t>Math.PI/2&&t<3*Math.PI/2}function A(t,e){return L(t-e)}function w(t,e){return new o((t.x+e.x)/2,(t.y+e.y)/2)}class f{constructor(t,e,i,s,r,n){this._angularVelocity=0,this._velocity=new l(0,0);const a=e*e+i*i;this._radiusLength=.5*Math.sqrt(a),this._momentOfInertia=f.scalingCoeff*r*a,this._mass=r,this._id=n,this._width=e,this._height=i,this._points=[t.clone(),new o(t.x+e,t.y),new o(t.x+e,t.y+i),new o(t.x,t.y+i)],0!==s&&E.rotateEntity(this,s)}get velocity(){return this._velocity}get angle(){return Math.atan2(this._points[1].y-this._points[0].y,this._points[1].x-this._points[0].x)}get points(){return this._points}get mass(){return this._mass}get angularVelocity(){return this._angularVelocity}set angularVelocity(t){this._angularVelocity=t}get id(){return this._id}get radiusLength(){return this._radiusLength}get momentOfInertia(){return this._momentOfInertia}calcCenter(){return w(this._points[0],this._points[2])}get lengthwiseArea(){const t=this.angle-this._velocity.angle;return this._height*Math.abs(Math.cos(t))+this._width*Math.abs(Math.sin(t))}get movementLength(){const t=this.angle-this._velocity.angle;return this._width*Math.abs(Math.cos(t))+this._height*Math.abs(Math.sin(t))}}f.scalingCoeff=.3125;class S{constructor(){}static extractType(t){return t%S.TYPE_DIVIDER}static isTank(t){return S.extractType(t)===S.TANK_TYPE}static isWall(t){return S.extractType(t)===S.WALL_TYPE}static isBullet(t){return S.extractType(t)===S.BULLET_TYPE}static checkForMaxValue(t){if(t>=S.MAX_VALUE)throw new Error("Maximum ID is reached.")}static get tankId(){return S.checkForMaxValue(S.TANK_ID),++S.TANK_ID*S.TYPE_DIVIDER+S.TANK_TYPE}static get wallId(){return S.checkForMaxValue(S.WALL_ID),++S.WALL_ID*S.TYPE_DIVIDER+S.WALL_TYPE}static get bulletId(){return S.checkForMaxValue(S.BULLET_ID),++S.BULLET_ID*S.TYPE_DIVIDER+S.BULLET_TYPE}static get collectibleItemId(){return S.checkForMaxValue(S.COLLECTIBLE_ITEM_ID),++S.COLLECTIBLE_ITEM_ID*S.TYPE_DIVIDER+S.COLLECTIBLE_ITEM_TYPE}}S.TANK_TYPE=0,S.WALL_TYPE=1,S.BULLET_TYPE=2,S.COLLECTIBLE_ITEM_TYPE=3,S.TYPE_DIVIDER=1e3,S.MAX_VALUE=Math.floor(Number.MAX_SAFE_INTEGER/S.TYPE_DIVIDER)-1,S.TANK_ID=0,S.WALL_ID=0,S.BULLET_ID=0,S.COLLECTIBLE_ITEM_ID=0;class y{constructor(){}static create(e,i,s,r){const n=y.createBullet(e),a=y.calcDefaultEntityPoint(e,i,s),o=new f(a,t.BULLET_WIDTH[e],t.BULLET_HEIGHT[e],s,n.mass,S.bulletId),l=n.startingSpeed*r.startingSpeedCoeff;return o.velocity.x=l*Math.cos(s),o.velocity.y=l*Math.sin(s),new I(n,o,r)}static calcDefaultEntityPoint(e,i,s){const r=new o(i.x+t.BULLET_HEIGHT[e]/2*Math.sin(s),i.y-t.BULLET_HEIGHT[e]/2*Math.cos(s)),n=Math.sin(s),a=Math.cos(s),l=new o(r.x+t.BULLET_WIDTH[e]/2*a-t.BULLET_HEIGHT[e]/2*n,r.y+t.BULLET_HEIGHT[e]/2*a+t.BULLET_WIDTH[e]/2*n);return p.rotatePointAroundTarget(r,l,-n,a),r}static createBullet(t){if(0===t)return new c;throw new Error(`Bullet model ${t} was not found`)}}function R(t,e){return Math.floor(Math.random()*(e+1-t))+t}class C{get angleSpeed(){return 6e-4}get mass(){return.35}get bulletCapacity(){return 3}get num(){return 0}}class N{get armorPenetrationCoeff(){return 1}get damageCoeff(){return 1}get startingSpeedCoeff(){return 1}get reloadSpeed(){return 1e3}get mass(){return.15}get num(){return 0}}class D extends m{get maxHealth(){return this._tankParts.hull.health}get maxArmor(){return this._tankParts.hull.armor}constructor(t,e){super(e,t.hull.health),this._lastTimeShot=Date.now(),this._bulletQuantity=0,this._bulletNum=D.DEFAULT_BULLET_NUM,this._isBraking=!1,this._isDrift=!1,this._tankParts=t,this._turretAngle=e.angle,this._armor=t.hull.armor}takeDamage(t){this._armor-=t.armorPenetration,this._armor<0&&(this._armor=0);const e=t.damage-this._armor*this.armorStrength;e>0&&(this._health-=e)}get turretAngle(){return this._turretAngle}get armor(){return this._armor}get armorStrength(){return this._tankParts.hull.armorStrength}get bulletNum(){return this._bulletNum}shot(){const t=Date.now();if(t-this._lastTimeShot<this._tankParts.weapon.reloadSpeed)return null;0===this._bulletQuantity?this._bulletNum=D.DEFAULT_BULLET_NUM:this._bulletQuantity--;const e=y.create(this._bulletNum,this.calcBulletExit(),this._turretAngle,this._tankParts.weapon);return this._lastTimeShot=t,e}calcBulletExit(){const e=this._entity.calcCenter(),i=this._tankParts,s=(n=i.turret,t.TURRET_WIDTH[n.num]/2+(r=i.weapon,t.WEAPON_WIDTH[r.num]));var r,n;const a=e.x+s*Math.cos(this._turretAngle),l=e.y+s*Math.sin(this._turretAngle);return new o(a,l)}takeBullet(t){this._bulletNum=t,this._bulletQuantity=this._tankParts.turret.bulletCapacity}turretClockwiseMovement(t){this._turretAngle+=this._tankParts.turret.angleSpeed*t}turretCounterclockwiseMovement(t){this._turretAngle-=this._tankParts.turret.angleSpeed*t}incTurretAngle(t){this._turretAngle+=t}hullClockwiseMovement(t,e,i){const s=this._entity,r=this._tankParts.track.angularData;s.angularVelocity<r.finishSpeed&&(s.angularVelocity+=_.calcAngularAcceleration(r.force,t,e,i,s.angularVelocity,s.mass,s.lengthwiseArea,s.radiusLength)),this.updateAngularVelocity(),this.incTurretAngle(s.angularVelocity)}hullCounterclockwiseMovement(t,e,i){const s=this._entity,r=this._tankParts.track.angularData;-s.angularVelocity<r.finishSpeed&&(s.angularVelocity-=_.calcAngularAcceleration(r.force,t,e,i,s.angularVelocity,s.mass,s.lengthwiseArea,s.radiusLength)),this.updateAngularVelocity(),this.incTurretAngle(s.angularVelocity)}updateAngularVelocity(){if(this.isIdle())return;const t=this._entity,e=t.velocity;(this._isDrift||this._isBraking)&&this.incAngularVelocity(t,e),this._isBraking||this.decAngularVelocity(t,e)}incAngularVelocity(t,e){const i=this.calcCoeff(),s=1+e.length/(this._tankParts.track.forwardData.finishSpeed*i),r=1+t.mass/(10*i);t.angularVelocity*=r*s}calcCoeff(){let t=100;return this._isDrift&&(t-=25),this._isBraking&&(t-=5),t}decAngularVelocity(t,e){const i=1-e.length/(20*this._tankParts.track.forwardData.finishSpeed),s=1-t.mass/200;t.angularVelocity*=s*i,e.scale(s)}forwardMovement(t,e,i){this.movement(this._tankParts.track.forwardData,this._entity.angle,t,e,i)}backwardMovement(t,e,i){this.movement(this._tankParts.track.backwardData,this._entity.angle+Math.PI,t,e,i)}movement(t,e,i,s,r){const n=this._entity,a=n.velocity.length,o=0===a?e:n.velocity.angle,l=A(e,o);this.setBrakingStatus(l),D.isStraightMovement(l)?(this._isDrift=!1,this.handleStraightMovement(t,i,s,r,a,o)):(this._isDrift=!D.isReverseMovement(l),this._isDrift&&(this.determineDribbleSpeed(l),this.applyTurn(this.calcShortestTurn(l))),this.handleDriftMovement(t,i,s,r,a,l,o))}setBrakingStatus(t){this._isBraking=M(t)}calcShortestTurn(t){return this._isBraking&&(t=D.adjustTurnForBraking(t)),t=D.adjustTurnForRecovery(t)}static isStraightMovement(t){return t<=e||2*Math.PI-t<=e}static isReverseMovement(t){return Math.abs(t-Math.PI)<=e}handleStraightMovement(t,e,i,s,r,n){if(r<t.finishSpeed){const a=_.calcAcceleration(t.force,e,i,s,r,this._entity.mass,this._entity.lengthwiseArea);this._entity.velocity.addToCoordinates(a*Math.cos(n),a*Math.sin(n))}}handleDriftMovement(t,e,i,s,r,n,a){if(this._isBraking||r<t.finishSpeed){const o=_.calcAcceleration(t.force*Math.cos(n),e,i,s,r,this._entity.mass,this._entity.lengthwiseArea);this.applyVelocityChange(o,a)}}static adjustTurnForBraking(t){return L(t-Math.PI/2)}static adjustTurnForRecovery(t){const e=t-2*Math.PI;return t>Math.abs(e)?e:t}applyTurn(t){t*=D.VELOCITY_RECOVERY_COEFF*this._entity.mass,p.rotatePoint(this._entity.velocity,Math.sin(t),Math.cos(t))}determineDribbleSpeed(t){const e=(Math.abs(Math.cos(t))-(i=0))/(1-i)*(1-(s=.95))+s;var i,s;this._entity.velocity.scale(e)}residualMovement(t,e,i){const s=A(this._entity.angle,this._entity.velocity.angle);(this._isDrift||!D.isStraightMovement(s)&&!D.isReverseMovement(s))&&(this._isDrift=!0,this.determineDribbleSpeed(s)),this._isBraking=!1,super.residualMovement(t,e,i)}residualAngularMovement(t,e,i){this.updateAngularVelocity(),super.residualAngularMovement(t,e,i),this.incTurretAngle(this._entity.angularVelocity)}}D.DEFAULT_BULLET_NUM=0,D.VELOCITY_RECOVERY_COEFF=.017;class P{constructor(){}static extractZIndex(t){return t%P.Z_INDEX_DIVIDER}static checkForMaxValue(t){if(t>=P.MAX_VALUE)throw new Error("Maximum ID is reached.")}static generate(t){for(let e=this.IDs.length;e<=t;e++)P.IDs.push(0);return P.checkForMaxValue(P.IDs[t]),++P.IDs[t]*P.Z_INDEX_DIVIDER+t}}P.Z_INDEX_DIVIDER=1e3,P.MAX_VALUE=Math.floor(Number.MAX_SAFE_INTEGER/P.Z_INDEX_DIVIDER)-1,P.IDs=new Array;class k{constructor(t,e,i){this._sprite=new Image(t,e),this._sprite.classList.add("sprite"),this._id=P.generate(i)}get width(){return this._sprite.width}get height(){return this._sprite.height}get sprite(){return this._sprite}get id(){return this._id}get point(){return this._point}get angle(){return this._angle}set point(t){this._point=t}set angle(t){this._angle=t}}class H extends k{constructor(t,e,i){super(t,e,1),this._opacity=1,this._sprite.src=`src/img/tanks/Effects/Tire Tracks/Tire_Track_Chain_${i}.png`}get opacity(){return this._opacity}set opacity(t){this._opacity=t}}class v{get value(){return this._value}get prev(){return this._prev}get next(){return this._next}set next(t){this._next=t}set prev(t){this._prev=t}constructor(t){this._prev=null,this._next=null,this._value=t}remove(){null!==this._prev&&(this._prev.next=this._next),null!==this._next&&(this._next.prev=this._prev),this._prev=null,this._next=null}}class O{constructor(){this._tail=null,this._head=null,this._length=0}get head(){return null!==this._head?this._head.value:null}get tail(){return null!==this._tail?this._tail.value:null}get length(){return this._length}*[Symbol.iterator](){let t=this._head;for(let e=this._length;e>0;e--)yield t.value,t=t.next}applyAndRemove(t,e,i){let s=this._head;for(;null!==s;)if(t(s.value,i),e(s.value)){const t=s;s=s.next,this.removeNode(t)}else s=s.next}isEmpty(){return 0===this._length}remove(t){let e=this._head;for(;null!==e;){if(e.value===t)return void this.removeNode(e);e=e.next}}removeNode(t){t===this._tail&&(this._tail=t.prev),t===this._head&&(this._head=t.next),this._length--,t.remove()}addToHead(t){const e=new v(t);null===this._head?(this._tail=e,this._head=e):(e.next=this._head,this._head.prev=e,this._head=e),this._length++}addToTail(t){const e=new v(t);null===this._tail?(this._tail=e,this._head=e):(e.prev=this._tail,this._tail.next=e,this._tail=e),this._length++}removeFromTail(){this._tail===this._head?this.clear():(this._tail=this._tail.prev,this._tail.next=null,this._length--)}removeFromHead(){this._tail===this._head?this.clear():(this._head=this._head.next,this._head.prev=null,this._length--)}moveToTail(t){let e=this._tail;for(;null!==e;){if(e.value===t){if(e!==this._tail){const t=e.prev,i=e.next;null!==t&&(t.next=i),null!==i&&(i.prev=t),e.next=null,e.prev=this._tail,this._tail.next=e,this._tail=e}return}e=e.prev}}moveToHead(t){let e=this._head;for(;null!==e;){if(e.value===t){if(e!==this._head){const t=e.prev,i=e.next;null!==t&&(t.next=i),null!==i&&(i.prev=t),e.next=this._head,e.prev=null,this._head.prev=e,this._head=e}return}e=e.next}}clear(){this._tail=this._head=null,this._length=0}}class G{constructor(){}static rotateToDefaultSpritePoint(t,e,i,s){const r=t.width>>1,n=t.height>>1;p.rotatePointAroundTarget(e,new o(e.x+r*s-n*i,e.y+n*s+r*i),-i,s)}static rotateToActualSpritePoint(t,e,i,s){const r=t.width>>1,n=t.height>>1;p.rotatePointAroundTarget(e,new o(e.x+r,e.y+n),i,s)}static updateSpritePart(t,e,i,s,r){G.rotateToDefaultSpritePoint(t,e,i,s),G.setPosAndAngle(t,e,r)}static setPosAndAngle(t,e,i){t.point=e,t.angle=i}static rotateForTurretPoint(t,e,i,s,r,n){const a=t.width>>1,l=t.height>>1;p.rotatePointAroundTarget(e,new o(e.x+a*s-l*i,e.y+l*s+a*i),r*s-n*i,s*n+i*r)}}class x extends k{constructor(t,e,i){super(t,e,1),this._opacity=1,this._sprite.src=`src/img/tanks/Effects/Tire Tracks/Tire_Track_${i}.png`}get opacity(){return this._opacity}set opacity(t){this._opacity=t}}var W,U;!function(t){t[t.dirForward=1]="dirForward",t[t.dirRotate=0]="dirRotate",t[t.dirBackward=1]="dirBackward"}(W||(W={}));class b{get chainWidth(){return this._chainWidth}constructor(t,e,i){this._listOfTirePairs=new O,this._vanishingListOfTirePairs=i,this._storage=t,this._trackWidth=e.width,this._trackHeight=e.height,this._trackType=e.num,this._chainWidth=this.calcWidthOfChain(),this._chainHeight=e.height,this._chainType=e.num%2}calcWidthOfChain(){return this._trackWidth/b.AMOUNT_OF_CHAINS}static calcPositionOfFirstChain(t,e,i,s,r){return new o(t.x+e*r-i*r,t.y+e*s-i*s)}moveToNextChain(t,e,i){t.x=t.x-this._chainWidth*i,t.y=t.y-this._chainWidth*e}vanishFullTrack(){for(const t of this._listOfTirePairs)this._vanishingListOfTirePairs.addToHead(this._listOfTirePairs.head),this._listOfTirePairs.removeFromHead()}static setAndPosTireTrackPair(t,e,i,s,r,n){const a=e.clone(),o=i.clone();G.rotateToDefaultSpritePoint(t.topTire,a,r,n),G.rotateToDefaultSpritePoint(t.bottomTire,o,r,n),G.setPosAndAngle(t.topTire,a,s),G.setPosAndAngle(t.bottomTire,o,s)}createTireTrackChainPair(t,e,i,s,r){const n={topTire:new H(this._chainWidth,this._chainHeight,this._chainType),bottomTire:new H(this._chainWidth,this._chainHeight,this._chainType)};return this._storage.insert(n.topTire),this._storage.insert(n.bottomTire),b.setAndPosTireTrackPair(n,t,e,i,s,r),n}createTireTrackPair(t,e,i,s,r){this.vanishFullTrack();const n={topTire:new x(this._trackWidth,this._trackHeight,this._trackType),bottomTire:new x(this._trackWidth,this._trackHeight,this._trackType)};this._storage.insert(n.topTire),this._storage.insert(n.bottomTire),b.setAndPosTireTrackPair(n,t,e,i,s,r),this._listOfTirePairs.addToHead(n)}calcFirstTopBottomChainPoints(t,e,i,s){const r=b.calcPositionOfFirstChain(e,this._trackWidth,this.chainWidth,i,s),n=t.hullSprite.calcPosition(e,i,s);let a=t.bottomTrackSprite.calcPosition(n,i,s);return a=b.calcPositionOfFirstChain(a,this._trackWidth,this.chainWidth,i,s),{topFirstChainPoint:r,bottomFirstChainPoint:a}}calcLastTopBottomChainPoints(t,e,i,s){const r=e.clone(),n=t.hullSprite.calcPosition(e,i,s);return{topLastChainPoint:r,bottomLastChainPoint:t.bottomTrackSprite.calcPosition(n,i,s)}}spawnFullTireTrack(t,e,i,s,r){this._topFirstChainPoint=t.clone(),this._bottomFirstChainPoint=e.clone();for(let n=0;n<b.AMOUNT_OF_CHAINS;n++){const a=this.createTireTrackChainPair(t,e,i,s,r);this._listOfTirePairs.addToHead(a),n===b.AMOUNT_OF_CHAINS-1&&(this._topLastChainPoint=t.clone(),this._bottomLastChainPoint=e.clone()),this.moveToNextChain(t,s,r),this.moveToNextChain(e,s,r)}}updateAllChainPoints(t,e,i,s){this._topFirstChainPoint=t,this._bottomFirstChainPoint=e,this._topLastChainPoint=i,this._bottomLastChainPoint=s}checkForUpdate(t,e,i,s){const r=T(t,this._topFirstChainPoint),n=T(e,this._bottomFirstChainPoint),a=T(i,this._topLastChainPoint),o=T(s,this._bottomLastChainPoint);return r>=this._chainWidth?{isUpdate:!0,prevPoint:this._topFirstChainPoint,currPoint:t}:n>=this._chainWidth?{isUpdate:!0,prevPoint:this._bottomFirstChainPoint,currPoint:e}:a>=this._chainWidth?{isUpdate:!0,prevPoint:this._topLastChainPoint,currPoint:i}:o>=this._chainWidth?{isUpdate:!0,prevPoint:this._bottomLastChainPoint,currPoint:s}:{isUpdate:!1}}getMovementAngle(t,e){const i=e.x-t.x,s=e.y-t.y;return Math.atan2(s,i)}detectMovementDirection(t,e,i){const s=this.getMovementAngle(t,e);let r=L(i-b.DIRECTION_ANGLE_DIFFERENCE,-Math.PI,Math.PI),n=L(i+b.DIRECTION_ANGLE_DIFFERENCE,-Math.PI,Math.PI),a=!1;if(r>=Math.PI/2&&r<=Math.PI&&n>=-Math.PI&&n<=-Math.PI/2&&(a=!0,s>=0?n=L(n,0,2*Math.PI):r=L(r,-2*Math.PI,0)),s>=r&&s<=n||s<=r&&s>=n)return W.dirForward;{a&&(r<0?(r=L(r,0,2*Math.PI),n=L(n,0,2*Math.PI)):(r=L(r,-2*Math.PI,0),n=L(n,-2*Math.PI,0)));const t=L(s-Math.PI,-Math.PI,Math.PI);return t>=r&&t<=n||t<=r&&t>=n?W.dirBackward:W.dirRotate}}forwardUpdate(t,e,i,s,r){const n=this.createTireTrackChainPair(t,e,i,s,r);this._listOfTirePairs.addToTail(n),this._listOfTirePairs.length>b.AMOUNT_OF_CHAINS&&(this._vanishingListOfTirePairs.addToHead(this._listOfTirePairs.head),this._listOfTirePairs.removeFromHead())}backwardUpdate(t,e,i,s,r){const n=this.createTireTrackChainPair(t,e,i,s,r);this._listOfTirePairs.addToHead(n),this._listOfTirePairs.length>b.AMOUNT_OF_CHAINS&&(this._vanishingListOfTirePairs.addToHead(this._listOfTirePairs.tail),this._listOfTirePairs.removeFromTail())}}b.DIRECTION_ANGLE_DIFFERENCE=.6,b.AMOUNT_OF_CHAINS=10;class F extends k{constructor(){super(t.ACCELERATION_SIZE,t.ACCELERATION_SIZE,2),this._frame=0,this._sprite.src="src/img/tanks/Effects/Movement/Movement.png"}set frame(t){this._frame=t}get frame(){return this._frame}get originalWidth(){return F.ORIGINAL_SIZE}get originalHeight(){return F.ORIGINAL_SIZE}}F.ORIGINAL_SIZE=256;class B{constructor(t,e,i){this._topSpriteAccelerationEffect=new F,this._bottomSpriteAccelerationEffect=new F,this._counter=0,this._frame=0,this._storage=t,this._indentX=e,this._tankHeight=i}changeFrame(){this._frame===B.LAST_Frame&&(this._frame=B.WORKING_Frame),this._counter++,this._counter===B.THRESHOLD&&(this._counter=0,this._frame++,this._topSpriteAccelerationEffect.frame=this._frame,this._bottomSpriteAccelerationEffect.frame=this._frame)}setPosition(t,e,i,s){0===this._frame&&0===this._counter&&(this._storage.insert(this._topSpriteAccelerationEffect),this._storage.insert(this._bottomSpriteAccelerationEffect)),this.changeFrame();let r=this.calcPosition(t,e,i,28*this._tankHeight/42);G.updateSpritePart(this._topSpriteAccelerationEffect,r,e,i,s),r=this.calcPosition(t,e,i,37*this._tankHeight/42),G.updateSpritePart(this._bottomSpriteAccelerationEffect,r,e,i,s)}removeAcceleration(){if(0===this._frame&&0===this._counter)return;this._frame=0,this._counter=0;const t=this._topSpriteAccelerationEffect,e=this._bottomSpriteAccelerationEffect;t.frame=this._frame,e.frame=this._frame,this._storage.remove(this._topSpriteAccelerationEffect),this._storage.remove(this._bottomSpriteAccelerationEffect)}calcPosition(e,i,s,r){return new o(e.x+this._indentX*s-r*i-t.ACCELERATION_SIZE/2*s+t.ACCELERATION_SIZE/1.517*i,e.y+r*s+this._indentX*i-t.ACCELERATION_SIZE/1.517*s-t.ACCELERATION_SIZE/2*i)}}B.THRESHOLD=7,B.LAST_Frame=19,B.WORKING_Frame=10;class V{constructor(t,e){this._frame=0,this._counter=0,this._isForwardMovement=!0,this._isResidualMovement=!1,this._minFrameChangeThreshold=[Math.max(Math.round(V.MIN_THRESHOLD_COEFF/e.finishSpeed),V.MIN_FRAME_CHANGE_THRESHOLD_MINIMUM),Math.max(Math.round(V.MIN_THRESHOLD_COEFF/t.finishSpeed),V.MIN_FRAME_CHANGE_THRESHOLD_MINIMUM)],this._maxFrameChangeThreshold=[Math.min(Math.round(V.MAX_THRESHOLD_COEFF/e.force),V.MAX_FRAME_CHANGE_THRESHOLD_MAXIMUM),Math.min(Math.round(V.MAX_THRESHOLD_COEFF/t.force),V.MAX_FRAME_CHANGE_THRESHOLD_MAXIMUM)],this._currentThreshold=this._maxFrameChangeThreshold[this._isForwardMovement?1:0]}set isForwardMovement(t){this._isResidualMovement=!1,this._isForwardMovement!==t&&(this._isForwardMovement=t,this._currentThreshold=this._maxFrameChangeThreshold[this._isForwardMovement?1:0])}setResidualMovement(){this._isResidualMovement=!0}changeFrame(t,e){this._counter++,this._counter>=this._currentThreshold&&(this._counter=0,this._frame^=1,t.frame=this._frame,e.frame=this._frame,this._isResidualMovement?this._currentThreshold<this._maxFrameChangeThreshold[this._isForwardMovement?1:0]&&this._currentThreshold++:this._currentThreshold>this._minFrameChangeThreshold[this._isForwardMovement?1:0]&&this._currentThreshold--)}stopped(){this._currentThreshold=this._maxFrameChangeThreshold[this._isForwardMovement?1:0]}}V.MIN_THRESHOLD_COEFF=17.5,V.MAX_THRESHOLD_COEFF=.5,V.MIN_FRAME_CHANGE_THRESHOLD_MINIMUM=2,V.MAX_FRAME_CHANGE_THRESHOLD_MAXIMUM=30;class X extends k{constructor(){super(...arguments),this._frame=0,this._isEnded=!1,this._timer=0}changeFrame(t){this._timer+=t,this._timer>=this.UPDATE_TIMER_TIME&&(this._timer-=this.UPDATE_TIMER_TIME,this._frame++,this._frame>this.MAX_FRAME&&(this._frame=this.MAX_FRAME,this._isEnded=!0))}get isEnded(){return this._isEnded}}class K extends X{get UPDATE_TIMER_TIME(){return K.UPDATE_TIMER_TIME}get MAX_FRAME(){return K.MAX_FRAME}constructor(t,e){super(t,e,1),this._sprite.src="src/img/tanks/Effects/Sprites/Sprite_Effects_Smoke.png"}set frame(t){this._frame=t}get frame(){return this._frame}get originalWidth(){return K.ORIGINAL_SIZE}get originalHeight(){return K.ORIGINAL_SIZE}}K.UPDATE_TIMER_TIME=60,K.MAX_FRAME=9,K.ORIGINAL_SIZE=496;class Y extends K{constructor(t,e){super(t,e)}get scaleX(){return-1}get scaleY(){return 1}calcPosition(t,e,i){return new o(t.x+this.width*e+this.height*i,t.y-this.width*i+this.height*e)}}class z extends K{constructor(t,e,i){super(t,e),this._trackHeight=i}calcPosition(t,e,i){return new o(t.x-this._trackHeight*e+this.height*i,t.y+this._trackHeight*i+this.height*e)}}!function(t){t[t.rotLeft=-1]="rotLeft",t[t.rotStraight=0]="rotStraight",t[t.rotRight=1]="rotRight",t[t.rotNoRotate=2]="rotNoRotate"}(U||(U={}));class Z{constructor(t,e,i){this._delayedAngle=0,this._animationManager=t,this._width=e/4,this._height=e/5,this._trackHeight=i}detectRotateDirection(t){(t>=Math.PI/2&&t<=Math.PI&&this._delayedAngle>=-Math.PI&&this._delayedAngle<=-Math.PI/2||this._delayedAngle>=Math.PI/2&&this._delayedAngle<=Math.PI&&t>=-Math.PI&&t<=-Math.PI/2)&&(t=this._delayedAngle>=0?L(t,0,2*Math.PI):L(t,-2*Math.PI,0));const e=t-this._delayedAngle;return e<0&&Math.abs(e)>Z.UPDATE_SMOKE_DELTA_ANGLE?(this._delayedAngle=L(t,-Math.PI,Math.PI),U.rotLeft):e>0&&Math.abs(e)>Z.UPDATE_SMOKE_DELTA_ANGLE?(this._delayedAngle=L(t,-Math.PI,Math.PI),U.rotRight):U.rotNoRotate}setPosAndAngle(t,e){const i=Math.sin(e),s=Math.cos(e);G.rotateToDefaultSpritePoint(this._currAnimation,t,i,s),this._currAnimation.point=t,this._currAnimation.angle=e}addAnimation(){this._animationManager.add(this._currAnimation)}spawnTopSmoke(t,e,i,s){this._currAnimation=new Y(this._width,this._height);let r=this._currAnimation.calcPosition(t,i,s);const n=e+1.5708;this.setPosAndAngle(r,n),this.addAnimation()}spawnBottomSmoke(t,e,i,s){this._currAnimation=new z(this._width,this._height,this._trackHeight);let r=this._currAnimation.calcPosition(t,i,s);const n=e+1.5708;this.setPosAndAngle(r,n),this.addAnimation()}}Z.UPDATE_SMOKE_DELTA_ANGLE=.113446;class ${constructor(t,e,i){this._tankSpriteParts=t,this._tankTrackEffect=new V(e,i)}get getParts(){return Object.values(this._tankSpriteParts)}get tankSpriteParts(){return this._tankSpriteParts}get tankTrackEffect(){return this._tankTrackEffect}get tankTireTrack(){return this._tankTireTrack}spawnTankAcceleration(t,e,i){this._tankAcceleration=new B(t,e,i)}removeAcceleration(){this._tankAcceleration.removeAcceleration()}spawnTireTracks(t,e,i,s){this._tankTireTrack=new b(t,this._tankSpriteParts.topTrackSprite,s);const r=Math.sin(i),n=Math.cos(i),{topFirstChainPoint:a,bottomFirstChainPoint:o}=this._tankTireTrack.calcFirstTopBottomChainPoints(this._tankSpriteParts,e,r,n);this._tankTireTrack.spawnFullTireTrack(a,o,i,r,n)}spawnDriftSmoke(t){this._tankDrift=new Z(t,this._tankSpriteParts.topTrackSprite.width,this._tankSpriteParts.topTrackSprite.height)}updateTireTrack(t,e,i,s){const{topFirstChainPoint:r,bottomFirstChainPoint:n}=this._tankTireTrack.calcFirstTopBottomChainPoints(this._tankSpriteParts,t,i,s),{topLastChainPoint:a,bottomLastChainPoint:o}=this._tankTireTrack.calcLastTopBottomChainPoints(this._tankSpriteParts,t,i,s),{isUpdate:l,prevPoint:h,currPoint:c}=this._tankTireTrack.checkForUpdate(r,n,a,o);if(l){this._tankTireTrack.updateAllChainPoints(r,n,a,o);switch(this._tankTireTrack.detectMovementDirection(h,c,e)){case W.dirForward:this._tankTireTrack.forwardUpdate(r,n,e,i,s);break;case W.dirRotate:this._tankTireTrack.createTireTrackPair(a,o,e,i,s);break;case W.dirBackward:this._tankTireTrack.backwardUpdate(a,o,e,i,s)}}}updateDriftSmoke(t,e,i,s){let r=this._tankSpriteParts.hullSprite.calcPosition(t,i,s);r=this._tankSpriteParts.bottomTrackSprite.calcPosition(r,i,s);switch(this._tankDrift.detectRotateDirection(e)){case U.rotLeft:this._tankDrift.spawnTopSmoke(t,e,i,s);break;case U.rotRight:this._tankDrift.spawnBottomSmoke(r,e,i,s)}}updateForwardAction(t,e,i){this._tankTrackEffect.isForwardMovement=!0;const s=Math.sin(e),r=Math.cos(e),n=this._tankSpriteParts.hullSprite.calcPosition(t,s,r);this.updateSprite(t,e,i,s,r,n),this._tankAcceleration.setPosition(n,s,r,e),this.updateTireTrack(t,e,s,r),this.updateDriftSmoke(t,e,s,r)}updateBackwardAction(t,e,i){this._tankTrackEffect.isForwardMovement=!1;const s=Math.sin(e),r=Math.cos(e);this.defaultUpdate(t,e,i,s,r),this.updateTireTrack(t,e,s,r),this.updateDriftSmoke(t,e,s,r)}preUpdateAction(t,e,i){const s=Math.sin(e),r=Math.cos(e);this.updateTireTrack(t,e,s,r),this.updateDriftSmoke(t,e,s,r),this.defaultUpdate(t,e,i,s,r)}updateAfterAction(t,e,i){const s=Math.sin(e),r=Math.cos(e);this.defaultUpdate(t,e,i,s,r)}defaultUpdate(t,e,i,s,r){const n=this._tankSpriteParts.hullSprite.calcPosition(t,s,r);this.updateSprite(t,e,i,s,r,n)}rotateTurretUpdate(t,e,i,s){const r=Math.sin(e),n=Math.cos(e),a=this._tankSpriteParts.turretSprite,o=a.calcPosition(t,i,s),l=o.clone();G.rotateForTurretPoint(a,l,i,s,r,n),G.rotateToDefaultSpritePoint(a,o,i,s),G.setPosAndAngle(a,o,e);let h=this._tankSpriteParts.weaponSprite.calcPosition(l,r,n);G.updateSpritePart(this._tankSpriteParts.weaponSprite,h,r,n,e)}updateSprite(t,e,i,s,r,n){const a=this._tankSpriteParts.topTrackSprite,o=this._tankSpriteParts.bottomTrackSprite,l=this._tankSpriteParts.hullSprite;let h=a.calcPosition(t);G.updateSpritePart(a,h,s,r,e),h=l.calcPosition(t,s,r),G.updateSpritePart(l,h,s,r,e),h=o.calcPosition(n,s,r),G.updateSpritePart(o,h,s,r,e),this.rotateTurretUpdate(n,i,s,r),this._tankTrackEffect.changeFrame(a,o)}}class j{get health(){return 100}get armor(){return 1}get mass(){return 1}get armorStrength(){return 20}get num(){return 0}}class q{constructor(){this._angularData={finishSpeed:.0175,force:.03},this._forwardData={finishSpeed:3,force:.03},this._backwardData={finishSpeed:2,force:.025}}get angularData(){return this._angularData}get forwardData(){return this._forwardData}get backwardData(){return this._backwardData}get num(){return 0}}class Q{constructor(t,e,i,s){this._hull=t,this._track=e,this._turret=i,this._weapon=s}get hull(){return this._hull}get track(){return this._track}get turret(){return this._turret}get weapon(){return this._weapon}}class J{constructor(){}static create(t,e,i,s){const r=J.createTurret(i),n=J.createWeapon(s),a=J.createHull(t),o=J.createTrack(e);return new Q(a,o,r,n)}static createHull(t){if(0===t)return new j;throw new Error(`Hull model ${t} was not found`)}static createTrack(t){if(0===t)return new q;throw new Error(`Track model ${t} was not found`)}static createTurret(t){if(0===t)return new C;throw new Error(`Turret model ${t} was not found`)}static createWeapon(t){if(0===t)return new N;throw new Error(`Weapon model ${t} was not found`)}}class tt extends k{get accelerationEffectIndentX(){return this._accelerationEffectIndentX}constructor(e,i){super(t.HULL_WIDTH[i],t.HULL_HEIGHT[i],4),this._accelerationEffectIndentX=t.ACCELERATION_EFFECT_INDENT_X[i],this._sprite.src=`src/img/tanks/Hulls/Hull_${i}/Hull_${e}.png`}calcPosition(e,i,s){return new o(e.x-t.TRACK_INDENT*i,e.y+t.TRACK_INDENT*s)}}class et extends k{static calcHeight(t){return et.PROPORTION_WIDTH_HEIGHT*t}get num(){return this._num}constructor(e,i,s){super(i+t.TRACK_INDENT,s,3),this._frame=0,this._num=e,this._sprite.src=`src/img/tanks/Tracks/Track_${e}.png`}set frame(t){this._frame=t}get frame(){return this._frame}get originalWidth(){return et.ORIGINAL_WIDTH}get originalHeight(){return et.ORIGINAL_HEIGHT}}et.PROPORTION_WIDTH_HEIGHT=42/246,et.ORIGINAL_WIDTH=246,et.ORIGINAL_HEIGHT=42;class it extends et{constructor(t,e){super(t,e,et.calcHeight(e))}calcPosition(t){return t.clone()}}class st extends et{constructor(e,i,s){const r=et.calcHeight(i);super(e,i,r),this._deltaHeight=s+t.TRACK_INDENT-r}calcPosition(t,e,i){return new o(t.x-this._deltaHeight*e,t.y+this._deltaHeight*i)}}class rt extends k{constructor(e,i,s,r){super(t.TURRET_WIDTH[i],t.TURRET_HEIGHT[i],5),this._sprite.src=`src/img/tanks/Turrets/Turret_${i}/Turret_${e}.png`,this._indentX=s,this._indentY=r}calcPosition(t,e,i){return new o(t.x+this._indentX*i-this._indentY*e,t.y+this._indentY*i+this._indentX*e)}}class nt extends k{constructor(e,i,s){super(t.WEAPON_WIDTH[e],t.WEAPON_HEIGHT[e],5),this._sprite.src=`src/img/tanks/Weapons/Weapon_${e}.png`,this._indentX=i,this._indentY=s}calcPosition(t,e,i){return new o(t.x+this._indentX*i-this._indentY*e,t.y+this._indentY*i+this._indentX*e)}}class at{constructor(t,e,i,s,r){this._hullSprite=t,this._bottomTrackSprite=e,this._topTrackSprite=i,this._turretSprite=s,this._weaponSprite=r}get hullSprite(){return this._hullSprite}get bottomTrackSprite(){return this._bottomTrackSprite}get topTrackSprite(){return this._topTrackSprite}get turretSprite(){return this._turretSprite}get weaponSprite(){return this._weaponSprite}}class ot{constructor(){}static create(e,i,s,r,n){return new at(new tt(e,i),new st(s,t.HULL_WIDTH[i],t.HULL_HEIGHT[i]),new it(s,t.HULL_WIDTH[i]),new rt(e,r,t.TURRET_INDENT_X[i],(t.HULL_HEIGHT[i]>>1)-(t.TURRET_HEIGHT[r]>>1)),new nt(n,9*t.TURRET_WIDTH[r]/10,(t.TURRET_HEIGHT[r]>>1)-(t.WEAPON_HEIGHT[n]>>1)))}}class lt{get model(){return this._model}get sprite(){return this._sprite}get id(){return this._model.entity.id}get tankInfo(){return this._tankInfo}set tankInfo(t){this._tankInfo=t}constructor(e,i,s){this._tankInfo=s;const r=J.create(s.hullNum,s.trackNum,s.turretNum,s.weaponNum),n=new f(e,t.HULL_WIDTH[s.hullNum]+t.TRACK_INDENT,t.HULL_HEIGHT[s.hullNum]+(t.TRACK_INDENT<<1),i,r.turret.mass+r.hull.mass+r.weapon.mass,S.tankId);this._model=new D(r,n);const a=r.track;this._sprite=new $(ot.create(s.color,s.hullNum,s.trackNum,s.turretNum,s.weaponNum),a.forwardData,a.backwardData)}spawn(t,e){const i=this._sprite.tankSpriteParts;t.insert(i.topTrackSprite),t.insert(i.bottomTrackSprite),t.insert(i.hullSprite),t.insert(i.weaponSprite),t.insert(i.turretSprite);const s=this._model.entity;e.insert(s),this._sprite.updateAfterAction(s.points[0],s.angle,this._model.turretAngle)}terminate(t,e){const i=this._sprite.tankSpriteParts;this._sprite.tankTireTrack.vanishFullTrack(),t.remove(i.topTrackSprite),t.remove(i.bottomTrackSprite),t.remove(i.hullSprite),t.remove(i.weaponSprite),t.remove(i.turretSprite),e.remove(this._model.entity)}}class ht{constructor(t,e){this._model=t,this._sprite=e}get model(){return this._model}get sprite(){return this._sprite}get id(){return this._model.entity.id}spawn(t,e){t.insert(this._sprite),e.insert(this._model.entity)}terminate(t,e){t.remove(this._sprite),e.remove(this._model.entity)}}class ct extends k{constructor(e,r){super(t.WALL_WIDTH[r],t.WALL_HEIGHT[r],3),this._sprite.src=`src/img/blocks/${i[e]}_${s[r]}.png`}updateAfterAction(t,e){t=t.clone(),G.rotateToDefaultSpritePoint(this,t,Math.sin(e),Math.cos(e)),G.setPosAndAngle(this,t,e)}}class _t extends m{constructor(t){super(t,1/0)}get maxHealth(){return 1/0}}class ut{constructor(){}static createWallsAroundPerimeter(e,i,s,r){const n=new Array,a=this.calcIndent(e,r.width),l=this.calcIndent(i,r.height-2*t.WALL_HEIGHT[0]);return this.createHorWalls(s,a,l,r,n),this.createVertWalls(s,a,l,r,n),{wallsArray:n,point:new o(a,l)}}static calcIndent(e,i){return(i-e*t.WALL_WIDTH[0])/2}static createHorWalls(e,i,s,r,n){for(let a=i;a<=r.width-i-t.WALL_WIDTH[this.RECT_NUM];a+=t.WALL_WIDTH[this.RECT_NUM])n.push(this.createWall(new o(a,s),0,e,this.RECT_NUM)),n.push(this.createWall(new o(a,r.height-t.WALL_HEIGHT[this.RECT_NUM]-s),0,e,this.RECT_NUM))}static createVertWalls(e,i,s,r,n){for(let a=s+t.WALL_HEIGHT[this.RECT_NUM]+(t.WALL_HEIGHT[this.RECT_NUM]>>1);a<=r.height-s-t.WALL_WIDTH[this.RECT_NUM];a+=t.WALL_WIDTH[this.RECT_NUM])n.push(this.createWall(new o(i-(t.WALL_HEIGHT[this.RECT_NUM]>>1),a),this.RAD_90,e,this.RECT_NUM)),n.push(this.createWall(new o(r.width-i-t.WALL_WIDTH[this.RECT_NUM]+(t.WALL_HEIGHT[this.RECT_NUM]>>1),a),this.RAD_90,e,this.RECT_NUM))}static createWall(e,i,s,n,a=!1){const o=a?r[s][n]:1/0,l=new _t(new f(e,t.WALL_WIDTH[n],t.WALL_HEIGHT[n],i,o,S.wallId)),h=new ct(s,n);return h.point=e,h.angle=i,new ht(l,h)}}ut.RAD_90=Math.PI/2,ut.RECT_NUM=0;class dt{constructor(){}static calcGridPoints(e){const i={GRID_COLUMNS_AMOUNT:12,GRID_LINES_AMOUNT:6,GRID_COLUMNS:[],GRID_LINES:[]},s=3*t.WALL_WIDTH[0]/2;for(let t=0;t<i.GRID_COLUMNS_AMOUNT;t++)i.GRID_COLUMNS[t]=e.x+t*s;for(let t=0;t<i.GRID_LINES_AMOUNT;t++)i.GRID_LINES[t]=e.y+t*s;return i}static makeHorWallLine(e,i,s,r,n,a,l){if(e.y===a.GRID_LINES[0]||e.y===a.GRID_LINES[a.GRID_LINES.length-1])throw new Error("Horizontal wall line was made on the obstacle!");e.x!==a.GRID_COLUMNS[0]&&s&&n.push(ut.createWall(e,0,l,1,!1));let h=new o(e.x+t.WALL_WIDTH[1],e.y);for(let s=0;s<i;s++){if(h.x>=a.GRID_COLUMNS[a.GRID_COLUMNS.length-1])throw new Error("Horizontal wall line was made on the obstacle!");n.push(ut.createWall(new o(h.x,h.y),0,l,0,!1)),h=new o(h.x+t.WALL_WIDTH[0],e.y),s!==i-1?(n.push(ut.createWall(new o(h.x,h.y),0,l,1,!1)),h=new o(h.x+t.WALL_WIDTH[1],e.y)):e.x+i*(t.WALL_WIDTH[0]+t.WALL_WIDTH[1])<a.GRID_COLUMNS[a.GRID_COLUMNS.length-1]&&r&&n.push(ut.createWall(new o(h.x,h.y),0,l,1,!1))}}static makeVertWallLine(e,i,s,r,n,a,l){if(e.x===a.GRID_COLUMNS[0]||e.x===a.GRID_COLUMNS[a.GRID_COLUMNS.length-1])throw new Error("Vertical wall line was made on the obstacle!");let h=new o(e.x,e.y);h.y!==a.GRID_LINES[0]&&s&&n.push(ut.createWall(h,0,l,1,!1)),h=new o(h.x,h.y+t.WALL_HEIGHT[1]);let c=new o(h.x+t.WALL_HEIGHT[0],h.y);p.rotatePointAroundTarget(c,new o(c.x-t.WALL_HEIGHT[0]/2,c.y+t.WALL_WIDTH[0]/2),Math.sin(-Math.PI/2),Math.cos(-Math.PI/2));for(let s=0;s<i;s++){if(h.y>=a.GRID_LINES[a.GRID_LINES.length-1])throw new Error("Vertical wall line was made on the obstacle!");n.push(ut.createWall(new o(c.x,c.y),Math.PI/2,l,0,!1)),c=new o(c.x,c.y+t.WALL_WIDTH[0]),h=new o(h.x,h.y+t.WALL_WIDTH[0]),s!==i-1?(n.push(ut.createWall(new o(h.x,h.y),0,l,1,!1)),h=new o(h.x,h.y+t.WALL_HEIGHT[1]),c=new o(c.x,c.y+t.WALL_HEIGHT[1])):e.y+i*(t.WALL_WIDTH[0]+t.WALL_HEIGHT[1])<a.GRID_LINES[a.GRID_LINES.length-1]&&r&&n.push(ut.createWall(new o(h.x,h.y),0,l,1,!1))}}static createMazeLvl1(t,e){const i=dt.calcGridPoints(e),s=new Array;return dt.makeVertWallLine(new o(i.GRID_COLUMNS[1],i.GRID_LINES[1]),1,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[0],i.GRID_LINES[2]),1,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[1],i.GRID_LINES[3]),1,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[1],i.GRID_LINES[4]),1,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[2],i.GRID_LINES[4]),1,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[2],i.GRID_LINES[0]),3,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[2],i.GRID_LINES[3]),1,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[3],i.GRID_LINES[1]),3,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[3],i.GRID_LINES[2]),2,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[5],i.GRID_LINES[2]),2,!1,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[5],i.GRID_LINES[3]),1,!1,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[4],i.GRID_LINES[4]),1,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[4],i.GRID_LINES[3]),1,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[5],i.GRID_LINES[0]),1,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[4],i.GRID_LINES[1]),3,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[6],i.GRID_LINES[1]),1,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[6],i.GRID_LINES[4]),1,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[8],i.GRID_LINES[1]),2,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[7],i.GRID_LINES[2]),2,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[7],i.GRID_LINES[2]),2,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[9],i.GRID_LINES[2]),1,!1,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[9],i.GRID_LINES[3]),1,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[8],i.GRID_LINES[3]),2,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[8],i.GRID_LINES[4]),1,!1,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[9],i.GRID_LINES[1]),1,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[10],i.GRID_LINES[1]),1,!1,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[10],i.GRID_LINES[2]),1,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[10],i.GRID_LINES[4]),1,!0,!0,s,i,t),s}static createMazeLvl2(t,e){const i=dt.calcGridPoints(e),s=new Array;return dt.makeHorWallLine(new o(i.GRID_COLUMNS[0],i.GRID_LINES[1]),2,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[2],i.GRID_LINES[1]),1,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[3],i.GRID_LINES[0]),2,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[3],i.GRID_LINES[2]),2,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[5],i.GRID_LINES[1]),2,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[5],i.GRID_LINES[1]),1,!1,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[5],i.GRID_LINES[3]),1,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[4],i.GRID_LINES[0]),1,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[0],i.GRID_LINES[4]),1,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[1],i.GRID_LINES[2]),1,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[1],i.GRID_LINES[3]),3,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[2],i.GRID_LINES[3]),2,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[7],i.GRID_LINES[0]),1,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[6],i.GRID_LINES[4]),1,!1,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[3],i.GRID_LINES[4]),5,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[7],i.GRID_LINES[2]),2,!1,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[6],i.GRID_LINES[2]),2,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[8],i.GRID_LINES[1]),2,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[9],i.GRID_LINES[0]),3,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[9],i.GRID_LINES[3]),1,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[10],i.GRID_LINES[1]),1,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[10],i.GRID_LINES[2]),1,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[9],i.GRID_LINES[4]),1,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[9],i.GRID_LINES[4]),1,!1,!0,s,i,t),s}static createMazeLvl3(t,e){const i=dt.calcGridPoints(e),s=new Array;return dt.makeVertWallLine(new o(i.GRID_COLUMNS[1],i.GRID_LINES[0]),1,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[0],i.GRID_LINES[2]),2,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[0],i.GRID_LINES[4]),1,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[3],i.GRID_LINES[0]),3,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[2],i.GRID_LINES[1]),1,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[1],i.GRID_LINES[3]),2,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[2],i.GRID_LINES[4]),1,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[4],i.GRID_LINES[3]),2,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[3],i.GRID_LINES[4]),1,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[6],i.GRID_LINES[0]),3,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[4],i.GRID_LINES[1]),2,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[6],i.GRID_LINES[2]),3,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[7],i.GRID_LINES[1]),1,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[9],i.GRID_LINES[1]),1,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[9],i.GRID_LINES[1]),1,!1,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[8],i.GRID_LINES[0]),1,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[6],i.GRID_LINES[4]),1,!1,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[5],i.GRID_LINES[4]),3,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[5],i.GRID_LINES[2]),2,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[4],i.GRID_LINES[2]),1,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[7],i.GRID_LINES[3]),1,!0,!0,s,i,t),dt.makeVertWallLine(new o(i.GRID_COLUMNS[9],i.GRID_LINES[3]),2,!1,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[8],i.GRID_LINES[3]),2,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[10],i.GRID_LINES[2]),1,!0,!0,s,i,t),dt.makeHorWallLine(new o(i.GRID_COLUMNS[10],i.GRID_LINES[4]),1,!0,!0,s,i,t),s}}class mt extends k{constructor(e){super(t.BACKGROUND_SIZE,t.BACKGROUND_SIZE,0),this._sprite.src=`src/img/backgrounds/${i[e]}_${R(0,1)}.png`}}class gt{constructor(){}static fullFillBackground(e,i,s){for(let r=0;r<i.width;r+=t.BACKGROUND_SIZE)for(let n=0;n<i.height;n+=t.BACKGROUND_SIZE)s.insert(this.addBackgroundTile(new o(r,n),e))}static addBackgroundTile(t,e){const i=new mt(e);return i.point=t,i}}class It{constructor(){}static dotProduct(t,e){return t.x*e.x+t.y*e.y}static crossProduct(t,e){return t.x*e.y-t.y*e.x}static add(t,e){return new l(t.x+e.x,t.y+e.y)}static subtract(t,e){return new l(t.x-e.x,t.y-e.y)}static scale(t,e){return new l(t.x*e,t.y*e)}static createFromAngleAndLength(t,e){return new l(e*Math.cos(t),e*Math.sin(t))}static calcCoDirectionalScaleFactor(t,e){return t.x/e.x}static calcScaleFactor(t,e){return t.length/e.length}}class pt{constructor(){}static hasCollision(t,e){const i=pt.getAxes(t),s=pt.getAxes(e);function r(i){for(const s of i){const i=pt.getProjection(t,s),r=pt.getProjection(e,s);if(Math.min(i.max-r.min,r.max-i.min)<=0)return!1}return!0}return r(i)&&r(s)}static getCollisionResult(t,e){const i=pt.getAxes(t),s=pt.getAxes(e);let r,n,a=Number.MAX_VALUE;function o(s){const o=s===i;for(const i of s){const s=pt.getProjection(t,i),l=pt.getProjection(e,i),h=Math.min(s.max-l.min,l.max-s.min);if(h<=0)return!1;h<a&&(a=h,r=i,n=o)}return!0}return o(i)&&o(s)?{collisionPoint:pt.findClosestVertex(t,e,r,n),overlap:a}:null}static findClosestVertex(t,e,i,s){let r,n;return s?(r=this.getProjection(t,i),n=this.getExtendedProjection(e,i,!1)):(r=this.getProjection(e,i),n=this.getExtendedProjection(t,i,!0)),n.max-r.min<r.max-n.min?n.maxPoint:n.minPoint}static getExtendedProjection(t,e,i){let s=It.dotProduct(e,t.points[0]),r=s,n=t.points[0],a=t.points[0];for(let o=1;o<t.points.length;o++){const l=It.dotProduct(e,t.points[o]);l<s?(s=l,n=t.points[o]):l>r?(r=l,a=t.points[o]):i&&Math.abs(l-s)<this.EPSILON?n=w(n,t.points[o]):i&&Math.abs(l-r)<this.EPSILON&&(a=w(a,t.points[o]))}return{min:s,max:r,minPoint:n,maxPoint:a}}static getAxes(t){const e=new Array,i=t.points.length-1;for(let s=0;s<i;s++)e.push(h.create(t.points[s],t.points[s+1]));return e.push(h.create(t.points[i],t.points[0])),e}static getProjection(t,e){let i=It.dotProduct(e,t.points[0]),s=i;for(let r=1;r<t.points.length;r++){const n=It.dotProduct(e,t.points[r]);n<i?i=n:n>s&&(s=n)}return{min:i,max:s}}}pt.EPSILON=1;class Et{constructor(){}static resolveCollision(t,e){const i=pt.getCollisionResult(t,e);if(null===i)return null;const s=this.calcCollisionNormal(i.collisionPoint,t.calcCenter()),r=this.calcImpulseMagnitude(t,e,s)+this.calcAngularImpulseMagnitude(t,e);return this.separateEntities(t,i.overlap,s),this.updateAngularVelocity(t,e,i.collisionPoint,r,s),this.updateVelocity(t,e,r,s),i.collisionPoint}static updateAngularVelocity(t,e,i,s,r){const n=this.calcEntityNormal(t),a=It.subtract(i,e.calcCenter()),o=It.subtract(i,t.calcCenter()),l=It.crossProduct(a,r)*s,h=It.crossProduct(o,n)*s,c=l/e.momentOfInertia;let _=h/t.momentOfInertia;this.shouldReverseReceiving(e.angle,n.angle)&&(_=-_),e.angularVelocity+=c,t.angularVelocity+=_}static shouldReverseReceiving(t,e){const i=L(t-e,0,Math.PI);return i<Math.PI/2&&i>Math.PI/4||i>=Math.PI/2&&i<3*Math.PI/4}static calcEntityNormal(t){const e=t.angle;return M(A(e,t.velocity.angle))?new l(-Math.cos(e),-Math.sin(e)):new l(Math.cos(e),Math.sin(e))}static updateVelocity(t,e,i,s){const r=It.scale(s,-i/t.mass),n=It.scale(s,i/e.mass);t.velocity.addVector(r),e.velocity.addVector(n)}static separateEntities(t,e,i){let s=-i.x*e,r=-i.y*e;s+=1===Math.sign(s)?this.CORRECTION_FACTOR:-this.CORRECTION_FACTOR,r+=1===Math.sign(r)?this.CORRECTION_FACTOR:-this.CORRECTION_FACTOR;for(const e of t.points)e.addToCoordinates(s,r);Math.abs(t.angularVelocity)>this.SMALL_ANGULAR_VELOCITY&&(t.angularVelocity-=1===Math.sign(t.angularVelocity)?this.CORRECTION_FACTOR/t.momentOfInertia:-this.CORRECTION_FACTOR/t.momentOfInertia)}static calcImpulseMagnitude(t,e,i){const s=It.subtract(t.velocity,e.velocity);return 2*It.dotProduct(s,i)/(1/t.mass+1/e.mass)*this.RETENTION_IMPULSE_COEFFICIENT}static calcAngularImpulseMagnitude(t,e){return Math.abs(t.angularVelocity-e.angularVelocity)/(1/t.momentOfInertia+1/e.momentOfInertia)*this.RETENTION_ANGULAR_IMPULSE_COEFFICIENT}static calcCollisionNormal(t,e){const i=It.subtract(t,e);return i.normalize(),i}}Et.RETENTION_IMPULSE_COEFFICIENT=.6,Et.RETENTION_ANGULAR_IMPULSE_COEFFICIENT=.012,Et.CORRECTION_FACTOR=.6,Et.SMALL_ANGULAR_VELOCITY=.001;class Tt{constructor(){this._idForProcessing=new Array}hasForProcessing(){return 0!==this._idForProcessing.length}clear(){this._idForProcessing.length=0}push(t){this._idForProcessing.push(t)}get iterable(){return this._idForProcessing}}class Lt{constructor(t){this._collisionDetection=t}hasCollision(t){const e=this._collisionDetection.getCollisions(t);return function(t){for(const e of t)return!0;return!1}(e)?e:null}}class Mt{get wallsForProcessing(){return this._wallsForProcessing}get collisionChecker(){return this._collisionDetector}constructor(t){this._wallsForProcessing=new Tt,this._collisionDetector=new Lt(t)}resolveCollision(t){const e=this._collisionDetector.hasCollision(t);if(e){const i=new Array;for(const s of e){const e=Et.resolveCollision(t,s);e&&(i.push({collisionPoint:e,id:s.id}),this.processCollision(s))}return i}return null}processCollision(t){S.isWall(t.id)&&this._wallsForProcessing.push(t.id)}}class At{constructor(t,e){this._rectangles=new Array,this._sprites=new Array,this._size=e,this._ctx=t,this._ctx.clearRect(0,0,this._size.width,this._size.height),this._bufferCanvas=document.createElement("canvas"),this._bufferCanvas.width=e.width,this._bufferCanvas.height=e.height,this._bufferCtx=this._bufferCanvas.getContext("2d")}get ctx(){return this._ctx}insert(t){const e=P.extractZIndex(t.id);for(let t=this._sprites.length;t<=e;t++)this._sprites.push(new Map);this._sprites[e].set(t.id,t)}remove(t){this.removeById(t)}removeById(t){const e=P.extractZIndex(t.id);this._sprites[e].delete(t.id)}drawAll(){this._bufferCtx.clearRect(0,0,this._size.width,this._size.height);for(const t of this._sprites)for(const e of t.values())this.draw(e);this.drawAdditionalShapes(),this._ctx.drawImage(this._bufferCanvas,0,0)}drawAdditionalShapes(){this.drawRectangles(),this._rectangles.length=0}drawRectangles(){for(const t of this._rectangles)this._bufferCtx.fillStyle=t.color,this._bufferCtx.fillRect(t.point.x,t.point.y,t.width,t.height)}addRectangle(t){this._rectangles.push(t)}clear(){this._sprites.length=0,this._rectangles.length=0}draw(t){this._bufferCtx.save();const e=t.width/2,i=t.height/2;"opacity"in t&&(this._bufferCtx.globalAlpha=t.opacity),this._bufferCtx.translate(t.point.x+e,t.point.y+i),this._bufferCtx.rotate(t.angle),function(t){return"scaleX"in t&&"scaleY"in t}(t)&&this._bufferCtx.scale(t.scaleX,t.scaleY),!function(t){return"frame"in t&&"originalWidth"in t&&"originalHeight"in t}(t)?this._bufferCtx.drawImage(t.sprite,-e,-i,t.width,t.height):this._bufferCtx.drawImage(t.sprite,t.frame*t.originalWidth,0,t.originalWidth,t.originalHeight,-e,-i,t.width,t.height),this._bufferCtx.restore()}}class wt{constructor(t,e,i,s){this._boundary={xStart:t,yStart:e,xLast:i,yLast:s},this._root=new ft(this._boundary)}insert(t){this._root.insert(t)}getCollisions(t){return this._root.getCollisions(t)}remove(t){this._root.remove(t)}clear(){this._root=new ft(this._boundary)}}class ft{constructor(t){this._totalPolygons=0,this._polygons=new Map,this._children=null,this._boundary=t}isSubdivide(){return null===this._polygons}subdivide(){const t=this._boundary.xStart,e=this._boundary.yStart,i=this._boundary.xLast,s=this._boundary.yLast,r=(i-t)/2,n=(s-e)/2;this._children=[new ft({xStart:t,yStart:e,xLast:t+r,yLast:e+n}),new ft({xStart:t+r,yStart:e,xLast:i,yLast:e+n}),new ft({xStart:t,yStart:e+n,xLast:t+r,yLast:s}),new ft({xStart:t+r,yStart:e+n,xLast:i,yLast:s})],this.redistribute()}redistribute(){this._totalPolygons=0;for(const t of this._children){for(const e of this._polygons.values())t.insert(e);this._totalPolygons+=t._totalPolygons}this._polygons=null}insert(t){if(this.isContainsPolygon(t))if(this.isSubdivide()){this._totalPolygons=0;for(const e of this._children)e.insert(t),this._totalPolygons+=e._totalPolygons}else this._totalPolygons++,this._polygons.set(t.id,t),this._polygons.size>ft.CAPACITY&&this.subdivide()}remove(t){if(this.isContainsPolygon(t))if(this.isSubdivide()){this._totalPolygons=0;for(const e of this._children)e.remove(t),this._totalPolygons+=e._totalPolygons;this._totalPolygons<=ft.HALF_CAPACITY&&this.mergeWithChildren()}else this._totalPolygons--,this._polygons.delete(t.id)}getCollisions(t){const e=new Array;if(this.isSubdivide())for(const i of this._children)i.isContainsPolygon(t)&&e.push(...i.getCollisions(t));else for(const i of this._polygons.values())pt.hasCollision(t,i)&&e.push(i);return e}isContainsPolygon(t){for(const e of t.points)if(this.isContainsPoint(e))return!0;return!1}isContainsPoint(t){return t.x>this._boundary.xStart&&t.x<this._boundary.xLast&&t.y>this._boundary.yStart&&t.y<this._boundary.yLast}mergeWithChildren(){this._polygons=new Map;for(const t of this._children){t.isSubdivide()&&t.mergeWithChildren();for(const e of t._polygons.values())this._polygons.set(e.id,e)}this._totalPolygons=this._polygons.size,this._children=null}}ft.CAPACITY=8,ft.HALF_CAPACITY=ft.CAPACITY>>1;class St{set resistanceCoeff(t){this._resistanceCoeff=t}set airResistanceCoeff(t){this._airResistanceCoeff=t}constructor(t,e){this._resistanceCoeff=0,this._airResistanceCoeff=0,this._entityStorage=t,this._collisionResolver=e}get entityStorage(){return this._entityStorage}get collisionResolver(){return this._collisionResolver}}class yt extends St{residualMovement(t,e){const i=t.sprite;t.model.isIdle()?i.tankTrackEffect.stopped():(i.tankTrackEffect.setResidualMovement(),this.hullUpdate(t,t.model.residualMovement,E.movement,t.sprite.preUpdateAction,e))}residualAngularMovement(t,e){t.model.isAngularMotionStopped()||this.hullUpdate(t,t.model.residualAngularMovement,E.angularMovement,t.sprite.preUpdateAction,e)}turretCounterclockwiseMovement(t,e){t.model.turretCounterclockwiseMovement(e),yt.turretUpdate(t)}turretClockwiseMovement(t,e){t.model.turretClockwiseMovement(e),yt.turretUpdate(t)}hullCounterclockwiseMovement(t,e){this.hullUpdate(t,t.model.hullCounterclockwiseMovement,E.angularMovement,t.sprite.preUpdateAction,e)}hullClockwiseMovement(t,e){this.hullUpdate(t,t.model.hullClockwiseMovement,E.angularMovement,t.sprite.preUpdateAction,e)}forwardMovement(t,e){this.hullUpdate(t,t.model.forwardMovement,E.movement,t.sprite.updateForwardAction,e)}backwardMovement(t,e){this.hullUpdate(t,t.model.backwardMovement,E.movement,t.sprite.updateBackwardAction,e)}hullUpdate(t,e,i,s,r){const n=t.model.entity;this._entityStorage.remove(n),e.call(t.model,this._resistanceCoeff,this._airResistanceCoeff,r),i(n),this._collisionResolver.resolveCollision(n)&&t.sprite.removeAcceleration(),s.call(t.sprite,n.points[0],n.angle,t.model.turretAngle),this._entityStorage.insert(n)}static turretUpdate(t){const e=t.model,i=e.entity.angle,s=Math.sin(i),r=Math.cos(i);t.sprite.rotateTurretUpdate(t.sprite.tankSpriteParts.hullSprite.calcPosition(e.entity.points[0],s,r),e.turretAngle,s,r)}}class Rt{constructor(){this._keys=new Set,this.keyDownHandler=this.handleKeyDown.bind(this),this.keyUpHandler=this.handleKeyUp.bind(this),document.addEventListener("keydown",this.keyDownHandler),document.addEventListener("keyup",this.keyUpHandler)}clearKeys(){this._keys.clear()}isKeyDown(t){return this._keys.has(t)}removeEventListeners(){document.removeEventListener("keydown",this.keyDownHandler),document.removeEventListener("keyup",this.keyUpHandler)}handleKeyDown(t){this._keys.add(t.keyCode)}handleKeyUp(t){this._keys.delete(t.keyCode)}}class Ct extends St{constructor(t,e){super(t,e)}get collisionResolver(){return this._collisionResolver}residualAngularMovement(t,e){t.model.isAngularMotionStopped()||this.update(t,t.model.residualAngularMovement,E.angularMovement,e)}residualMovement(t,e){t.model.isIdle()||this.update(t,t.model.residualMovement,E.movement,e)}update(t,e,i,s){const r=t.model.entity;this._entityStorage.remove(r),e.call(t.model,this._resistanceCoeff,this._airResistanceCoeff,s),i(r),this._collisionResolver.resolveCollision(r),t.sprite.updateAfterAction(r.points[0],r.angle),this._entityStorage.insert(r)}isCompleteMotion(t){return t.model.isAngularMotionStopped()&&t.model.isIdle()}movement(t,e){this.residualAngularMovement(t,e),this.residualMovement(t,e)}}class Nt{constructor(t,e,i,s){this._movementManager=t,this._spriteStorage=e,this._elements=i,this._isResponsibleFor=s}get movementManager(){return this._movementManager}get isResponsibleFor(){return this._isResponsibleFor}get(t){return this._elements.has(t)?this._elements.get(t):null}add(t){for(const e of t)this._elements.has(e.id)||(this._elements.set(e.id,e),e.spawn(this._spriteStorage,this._movementManager.entityStorage))}delete(t){this._elements.has(t.id)&&(this._elements.delete(t.id),t.terminate(this._spriteStorage,this._movementManager.entityStorage))}}class Dt{constructor(t){this._vanishingListOfTirePairs=new O,this.tanksAmount=0,this._storage=t}get vanishingListOfTirePairs(){return this.tanksAmount++,this._vanishingListOfTirePairs}removeTireTrackPair(t){this._storage.remove(t.topTire),this._storage.remove(t.bottomTire)}reduceOpacity(){let t=0;for(const e of this._vanishingListOfTirePairs){const i=this._vanishingListOfTirePairs.length*Dt.MIN_REDUCING_OPACITY_NUMBER/this.tanksAmount;e.topTire.opacity-=i,e.bottomTire.opacity-=i,e.topTire.opacity<=0&&t++}for(;t>0;t--)this.removeTireTrackPair(this._vanishingListOfTirePairs.tail),this._vanishingListOfTirePairs.removeFromTail()}}Dt.MIN_REDUCING_OPACITY_NUMBER=1e-4;class Pt extends X{get UPDATE_TIMER_TIME(){return Pt.UPDATE_TIMER_TIME}get MAX_FRAME(){return Pt.MAX_FRAME}constructor(e,i){super(t.EXPLOSION_SIZE,t.EXPLOSION_SIZE,1),this._sprite.src="src/img/tanks/Effects/Sprites/Sprite_Effects_Explosion.png",this._point=new o(e.x-t.EXPLOSION_SIZE/2,e.y-t.EXPLOSION_SIZE/2),this._angle=i}set frame(t){this._frame=t}get frame(){return this._frame}get originalWidth(){return Pt.ORIGINAL_SIZE}get originalHeight(){return Pt.ORIGINAL_SIZE}}Pt.UPDATE_TIMER_TIME=90,Pt.MAX_FRAME=8,Pt.ORIGINAL_SIZE=256;class kt extends X{get UPDATE_TIMER_TIME(){return kt.UPDATE_TIMER_TIME}get MAX_FRAME(){return kt.MAX_FRAME}constructor(t,e,i,s,r){super(i,s,1),this._sprite.src=`src/img/tanks/Effects/Sprites/Sprite_Fire_Shots_Impact_${0===r?0:1}.png`;const n=new o(t.x+s/2*Math.sin(e),t.y-s/2*Math.cos(e));G.rotateToDefaultSpritePoint(this,n,Math.sin(e),Math.cos(e)),this._point=n,this._angle=e}set frame(t){this._frame=t}get frame(){return this._frame}get originalWidth(){return kt.ORIGINAL_WIDTH}get originalHeight(){return kt.ORIGINAL_HEIGHT}}kt.UPDATE_TIMER_TIME=70,kt.MAX_FRAME=3,kt.ORIGINAL_WIDTH=120,kt.ORIGINAL_HEIGHT=205;class Ht extends X{get UPDATE_TIMER_TIME(){return Ht.UPDATE_TIMER_TIME}get MAX_FRAME(){return Ht.MAX_FRAME}constructor(t,e,i,s,r){super(i,s,1),this._sprite.src=`src/img/tanks/Effects/Sprites/Sprite_Fire_Shots_Shot_${0===r?0:1}.png`;const n=new o(t.x+s/2*Math.sin(e),t.y-s/2*Math.cos(e));G.rotateToDefaultSpritePoint(this,n,Math.sin(e),Math.cos(e)),this._point=n,this._angle=e}set frame(t){this._frame=t}get frame(){return this._frame}get originalWidth(){return Ht.ORIGINAL_WIDTH}get originalHeight(){return Ht.ORIGINAL_HEIGHT}}Ht.UPDATE_TIMER_TIME=45,Ht.MAX_FRAME=3,Ht.ORIGINAL_WIDTH=135,Ht.ORIGINAL_HEIGHT=202;class vt{static playDeathAnimation(t,e){if(S.isWall(e.id),S.isTank(e.id))return new Pt(e.model.entity.calcCenter(),R(-Math.PI,Math.PI));if(S.isBullet(e.id)){const i=e;return this.playImpactAnimation(t,i.model.entity.angle+Math.PI,i.sprite.num)}}static playImpactAnimation(e,i,s){return new kt(e,i,5*t.BULLET_WIDTH[s],5*t.BULLET_HEIGHT[s],s)}static playShootAnimation(e,i,s){return new Ht(e,i,5*t.BULLET_WIDTH[s],5*t.BULLET_HEIGHT[s],s)}}class Ot{constructor(t){this._animationManager=t}get animationManager(){return this._animationManager}createImpactAnimation(t,e){this._animationManager.add(vt.playImpactAnimation(t,e.model.entity.angle+Math.PI,e.sprite.num))}createDeadAnimation(t,e){this._animationManager.add(vt.playDeathAnimation(t,e))}}class Gt{constructor(t){this._animationManager=t}get animationManager(){return this._animationManager}createShootAnimation(t,e){this._animationManager.add(vt.playShootAnimation(w(t.entity.points[0],t.entity.points[3]),t.entity.angle,e))}}class xt extends k{get num(){return this._num}constructor(e){super(t.BULLET_WIDTH[e],t.BULLET_HEIGHT[e],3),this._sprite.src=`src/img/tanks/Bullets/Bullet_${e}.png`,this._num=e}updateAfterAction(t,e){t=t.clone(),G.rotateToDefaultSpritePoint(this,t,Math.sin(e),Math.cos(e)),G.setPosAndAngle(this,t,e)}}class Wt{constructor(t,e,i){this._model=t,this._sprite=new xt(e),this._source=i}get id(){return this._model.entity.id}get model(){return this._model}get sprite(){return this._sprite}spawn(t,e){t.insert(this._sprite),e.insert(this._model.entity)}terminate(t,e){t.remove(this._sprite),e.remove(this._model.entity)}get source(){return this._source}}class Ut extends Nt{constructor(t,e,i,s,r,n,a){super(t,e,i,S.isTank),this._addBulletElement=s,this._KeyHandler=n,this._tankAnimator=new Gt(r),this._tireTracksManager=new Dt(e),this._bonusCollisionManager=a}handle(t){this._tireTracksManager.reduceOpacity();for(const e of this._elements.values()){const i=e.tankInfo.control;let s=this._KeyHandler.isKeyDown(i.turretClockwiseKey),r=this._KeyHandler.isKeyDown(i.turretCounterClockwiseKey);if((s&&!r||!s&&r)&&(s?this._movementManager.turretClockwiseMovement(e,t):r&&this._movementManager.turretCounterclockwiseMovement(e,t)),s=this._KeyHandler.isKeyDown(i.forwardKey),r=this._KeyHandler.isKeyDown(i.backwardKey),s&&!r||!s&&r?s?this._movementManager.forwardMovement(e,t):r&&(e.sprite.removeAcceleration(),this._movementManager.backwardMovement(e,t)):(e.sprite.removeAcceleration(),this._movementManager.residualMovement(e,t)),s=this._KeyHandler.isKeyDown(i.hullClockwiseKey),r=this._KeyHandler.isKeyDown(i.hullCounterClockwiseKey),s&&!r||!s&&r?s?this._movementManager.hullClockwiseMovement(e,t):r&&this._movementManager.hullCounterclockwiseMovement(e,t):this._movementManager.residualAngularMovement(e,t),s=this._KeyHandler.isKeyDown(i.shootKey),s){const t=e.model.shot();if(t){const i=e.model.bulletNum;this._tankAnimator.createShootAnimation(t,i),this._addBulletElement.addElement(new Wt(t,i,e))}}this._bonusCollisionManager.checkForBonusHits(e)}}add(t){super.add(t);for(const e of t){const t=e.sprite,i=e.model.entity;t.spawnTireTracks(this._spriteStorage,i.points[0],i.angle,this._tireTracksManager.vanishingListOfTirePairs),t.spawnDriftSmoke(this._tankAnimator.animationManager);const s=t.tankSpriteParts.hullSprite;t.spawnTankAcceleration(this._spriteStorage,s.accelerationEffectIndentX,s.height)}}}class bt extends Nt{constructor(t,e,i){super(t,e,i,S.isWall),this._wallToProcess=new O}addToProcess(){const t=this._movementManager.collisionResolver.wallsForProcessing;if(t.hasForProcessing()){for(const e of t.iterable)this._wallToProcess.addToTail(this._elements.get(e));t.clear()}}handle(t){this.addToProcess(),this._wallToProcess.isEmpty()||this._wallToProcess.applyAndRemove(this._movementManager.movement.bind(this._movementManager),this._movementManager.isCompleteMotion.bind(this._movementManager),t)}}class Ft{constructor(t){this._animationList=new O,this._storage=t}add(t){this._storage.insert(t),this._animationList.addToTail(t)}handle(t){this._animationList.isEmpty()||this._animationList.applyAndRemove(((t,e)=>t.changeFrame(e)),this.removalCondition.bind(this),t)}removalCondition(t){return t.isEnded&&this._storage.removeById(t),t.isEnded}}class Bt extends Nt{constructor(t,e,i,s,r,n,a){super(t,e,i,S.isBullet),this._handlingManagers=s,this._bulletAnimator=new Ot(r),this._rulesManager=n,this._healthManager=a}handle(t){if(0!==this._elements.size){const e=new Array;for(const i of this._elements.values())this._movementManager.movement(i,t),this._movementManager.hasResidualMovement(i)||e.push(i);for(const t of e)this.delete(t)}this._movementManager.bulletCollisionDates.hasForProcessing()&&this.handleBulletCollisions()}handleBulletCollisions(){for(const t of this._movementManager.bulletCollisionDates.iterable){for(const e of t.collisionPacks){this._bulletAnimator.createImpactAnimation(e.collisionPoint,t.bulletElement);const i=e.id,s=this.getElementHandling(i),r=s.get(i);r&&(r.model.takeDamage(t.bulletElement.model),r.model.isDead()?(s.delete(r),this._bulletAnimator.createDeadAnimation(e.collisionPoint,r),this._healthManager.remove(r.model),S.isTank(r.id)&&this._rulesManager.addBonus(t.bulletElement.source,a.kill)):this._healthManager.add(r.model))}this.delete(t.bulletElement),this._healthManager.remove(t.bulletElement.model)}this._movementManager.bulletCollisionDates.clear()}getElementHandling(t){for(const e of this._handlingManagers)if(e.isResponsibleFor(t))return e}}class Vt{constructor(t,e,i){this._elements=t,this._storage=e,this._bulletMovementManager=i}addElement(t){this._elements.has(t.id)||this._bulletMovementManager.checkForSpawn(t)&&(this._elements.set(t.id,t),t.spawn(this._storage,this._bulletMovementManager.entityStorage))}}class Xt{constructor(){}static movePolygon(t,e){for(const i of t.points)i.addToCoordinates(e.x,e.y)}static rotatePolygon(t,e){const i=Math.sin(e),s=Math.cos(e),r=t.calcCenter();for(const e of t.points)p.rotatePointAroundTarget(e,r,i,s)}}class Kt extends St{constructor(){super(...arguments),this._bulletCollisionDates=new Tt}get bulletCollisionDates(){return this._bulletCollisionDates}hasResidualMovement(t){return!t.model.isIdle()}movement(t,e){t.model.isIdle()||this.update(t,e)}update(t,e){const i=t.model.entity;this._entityStorage.remove(i),t.model.residualMovement(this._airResistanceCoeff,e);const s=It.createFromAngleAndLength(i.velocity.angle,i.movementLength);let r=!1;const n=Math.floor(It.calcCoDirectionalScaleFactor(i.velocity,s));for(let e=n;e>0;e--){Xt.movePolygon(i,s);const e=this._collisionResolver.resolveCollision(i);if(e){this._bulletCollisionDates.push({bulletElement:t,collisionPacks:e}),r=!0;break}}if(!r){s.scale(-n),s.addVector(i.velocity),Xt.movePolygon(i,s);const e=this._collisionResolver.resolveCollision(i);e&&this._bulletCollisionDates.push({bulletElement:t,collisionPacks:e})}t.sprite.updateAfterAction(i.points[0],i.angle),this._entityStorage.insert(i)}checkForSpawn(t){const e=t.model.entity,i=this._collisionResolver.resolveCollision(e);return i?(this._bulletCollisionDates.push({bulletElement:t,collisionPacks:i}),!1):(t.sprite.updateAfterAction(e.points[0],e.angle),!0)}}class Yt{constructor(){this._executioners=new Array}add(...t){this._executioners.push(...t)}renderAll(t){for(const e of this._executioners)e.handle(t)}}class zt{constructor(t){this._isGameLoopActive=!1,this._lastFrameTime=performance.now(),this._render=new Yt,this._drawable=t}get render(){return this._render}start(){this._isGameLoopActive||(this._isGameLoopActive=!0,requestAnimationFrame((()=>this.gameLoop())))}stop(){this._isGameLoopActive=!1}gameLoop(){if(!this._isGameLoopActive)return;const t=performance.now();this._render.renderAll(t-this._lastFrameTime),this._drawable.drawAll(),this._lastFrameTime=t,requestAnimationFrame((()=>this.gameLoop()))}}class Zt{get collisionChecker(){return this._collisionDetector}constructor(t,e,i){this._items=new Map,this._spriteStorage=t;const s=new wt(0,0,i.width,i.height);this._collectibleStorage=s,this._collisionDetector=new Lt(s),this._rulesManager=e}addElements(t){for(const e of t)this.addElement(e)}addElement(t){this._items.has(t.id)||(this._items.set(t.id,t),t.spawn(this._spriteStorage,this._collectibleStorage))}checkForBonusHits(t){const e=this._collisionDetector.hasCollision(t.model.entity);if(e)for(const i of e)this._rulesManager.addBonus(t,i.bonus)&&this.delete(this._items.get(i.id))}delete(t){this._items.delete(t.id),t.terminate(this._spriteStorage,this._collectibleStorage)}}class $t{get point(){return this._point}get width(){return this._width}get height(){return this._height}get color(){return this._color}constructor(t,e,i,s){this._point=t,this._width=e,this._height=i,this._color=s}}class jt{constructor(t){this._drawList=new Map,this._shapeAdder=t}add(t){t.maxHealth!==1/0&&this._drawList.set(t.entity.id,t)}remove(t){this._drawList.delete(t.entity.id)}handle(){this.drawBars()}drawBars(){for(const t of this._drawList.values())this.drawBar(t)}drawBar(t){const e=this.calculateTankWidth(t),i=e/t.maxHealth*t.health,s=T(t.entity.points[1],t.entity.points[2]),r=t.entity.calcCenter(),n=new o(r.x-i/2,r.y-1.5*s);var a;this.drawHealthBar(n,i,this.getHealthColor(t)),"armor"in(a=t)&&"armorStrength"in a&&"maxArmor"in a&&this.drawArmorBar(t,e,n)}calculateTankWidth(t){return 1.15*T(t.entity.points[0],t.entity.points[1])}getHealthColor(t){return t.health>.4*t.maxHealth?"green":t.health>.15*t.maxHealth&&t.health<=.4*t.maxHealth?"yellow":"red"}drawHealthBar(e,i,s){this._shapeAdder.addRectangle(new $t(e,i,t.HEALTH_BAR_HEIGHT,s))}drawArmorBar(e,i,s){const r=i/e.maxArmor*e.armor,n=e.entity.calcCenter(),a=new o(n.x-r/2,s.y+t.HEALTH_BAR_HEIGHT+t.HEALTH_ARMOR_BAR_INDENT_Y);this._shapeAdder.addRectangle(new $t(a,r,t.ARMOR_BAR_HEIGHT,"blue"))}}class qt{get modelCollisionManager(){return this._modelCollisionManager}get itemCollisionManager(){return this._itemCollisionManager}get size(){return this._size}get ctx(){return this._canvas.ctx}constructor(t,e,i){this._handlingManagers=new Array,this._keyHandler=new Rt,this.handleVisibilityChange=()=>{document.hidden?(this._gameLoop.stop(),this._keyHandler.clearKeys()):this._gameLoop.start()},document.addEventListener("visibilitychange",this.handleVisibilityChange),this._size=e,this._canvas=new At(t,this._size),this._gameLoop=new zt(this._canvas),this._animationManager=new Ft(this._canvas),this._healthDrawManager=new jt(this._canvas);const s=new wt(0,0,this._size.width,this._size.height);this._modelCollisionManager=new Mt(s);const r=new Map,n=new Map,a=new Map,o=new yt(s,this._modelCollisionManager),l=new Ct(s,this._modelCollisionManager),h=new Kt(s,this._modelCollisionManager),c=new Vt(a,this._canvas,h);this._itemCollisionManager=new Zt(this._canvas,i,this._size),this._tankHandlingManagers=new Ut(o,this._canvas,r,c,this._animationManager,this._keyHandler,this._itemCollisionManager),this._wallHandlingManagers=new bt(l,this._canvas,n),this._bulletHandlingManager=new Bt(h,this._canvas,a,this._handlingManagers,this._animationManager,i,this._healthDrawManager),this._handlingManagers.push(this._tankHandlingManagers,this._wallHandlingManagers,this._bulletHandlingManager),this._gameLoop.render.add(...this._handlingManagers,this._animationManager,this._healthDrawManager),this._gameLoop.start()}removeEventListeners(){this._keyHandler.removeEventListeners(),document.removeEventListener("visibilitychange",this.handleVisibilityChange)}setBackgroundMaterial(t){this.setCoefficients(t),this.createBackgroundSprites(t)}setCoefficients(t){for(const e of this._handlingManagers)e.movementManager.resistanceCoeff=n[t],e.movementManager.airResistanceCoeff=15e-7}createBackgroundSprites(t){gt.fullFillBackground(t,this._size,this._canvas)}addWallElements(t){this._wallHandlingManagers.add(t)}addTankElements(...t){this._tankHandlingManagers.add(t);for(const e of t)this._healthDrawManager.add(e.model)}addBonuses(...t){this._itemCollisionManager.addElements(t)}addExecutioners(...t){this._gameLoop.render.add(...t)}finishGame(){this._gameLoop.stop(),this.ctx.clearRect(0,0,this._size.width,this._size.height)}}class Qt{constructor(t,e){this._collectible=t,this._sprite=e}get id(){return this._collectible.id}get collectible(){return this._collectible}get sprite(){return this._sprite}spawn(t,e){t.insert(this._sprite),e.insert(this._collectible)}terminate(t,e){t.remove(this._sprite),e.remove(this._collectible)}adjustPolygon(t,e){this._collectible.adjustPolygon(t,this._sprite.width,this._sprite.height,e),this._sprite.point=t,this._sprite.angle=e}}class Jt{constructor(t,e,i,s,r,n){this._id=r,this._bonus=n,this.adjustPolygon(t,e,i,s)}get bonus(){return this._bonus}get id(){return this._id}get points(){return this._points}calcCenter(){return w(this._points[0],this._points[2])}adjustPolygon(t,e,i,s){this._points=[t.clone(),new o(t.x+e,t.y),new o(t.x+e,t.y+i),new o(t.x,t.y+i)],0!==s&&Xt.rotatePolygon(this,s)}}class te extends k{constructor(e,i){super(t.KEY_SIZE,t.KEY_SIZE,6),this._scaleX=1,this._isIncreasing=!1,this._point=e,this._angle=i,this._sprite.src="src/img/item/Key.png"}get scaleX(){return this._isIncreasing?(this._scaleX+=te.CHANGE_SCALE_X_NUMBER,this._scaleX>=1&&(this._isIncreasing=!1)):(this._scaleX-=te.CHANGE_SCALE_X_NUMBER,this._scaleX<=-1&&(this._isIncreasing=!0)),this._scaleX}get scaleY(){return 1}}te.CHANGE_SCALE_X_NUMBER=.01;class ee extends k{constructor(e,i,s){switch(super(t.BOX_SIZE,t.BOX_SIZE,6),this._point=i,this._angle=s,e){case a.bulLight:this._sprite.src="src/img/item/Light_Bullet_Box.png";break;case a.bulMedium:this._sprite.src="src/img/item/Medium_Bullet_Box.png";break;case a.bulHeavy:this._sprite.src="src/img/item/Heavy_Bullet_Box.png";break;case a.bulGrenade:this._sprite.src="src/img/item/Grenade_Bullet_Box.png";break;case a.bulSniper:this._sprite.src="src/img/item/Sniper_Bullet_Box.png";break;default:throw new Error(`Unsupported bulletType: ${e}`)}}}class ie{constructor(){}static create(e,i,s){const r=S.collectibleItemId;switch(e){case a.key:return new Qt(new Jt(i,t.KEY_SIZE,t.KEY_SIZE,s,r,e),new te(i,s));case a.bulLight:case a.bulMedium:case a.bulHeavy:case a.bulSniper:case a.bulGrenade:return new Qt(new Jt(i,t.BOX_SIZE,t.BOX_SIZE,s,r,e),new ee(e,i,s))}}}class se{constructor(t,e){this._ammoSpawnInterval=5e3,this._timer=0,this._spawnPoints=t,this._collectibleItemManager=e}handle(e){this._timer+=e,this._timer>=this._ammoSpawnInterval&&(this.spawnRandomBox(this.getRandomBox(),this._spawnPoints.getRandomSpawnPoint(t.BOX_SIZE,t.BOX_SIZE)),this._timer=0,this._ammoSpawnInterval<se.MAX_AMMO_SPAWN_INTERVAL&&(this._ammoSpawnInterval+=R(1e3,5e3)))}getRandomBox(){const t=R(1,100);return t<40?a.bulMedium:t<70?a.bulHeavy:a.bulGrenade}spawnRandomBox(e,i){const s=ie.create(e,i,0);for(let e=0;e<se.RESPAWN_TRYS_AMOUNT;e++){if(!this._collectibleItemManager.collisionChecker.hasCollision(s.collectible)){this._collectibleItemManager.addElement(s);break}s.adjustPolygon(this._spawnPoints.getRandomSpawnPoint(t.BOX_SIZE,t.BOX_SIZE),0)}}randomSpawn(t,e,i,s,r,n,a){const o=ie.create(t,this._spawnPoints.getRandomSpawnPoint(e,i,s,r,n,a),0);for(let t=0;t<se.RESPAWN_TRYS_AMOUNT;t++){if(!this._collectibleItemManager.collisionChecker.hasCollision(o.collectible))return void this._collectibleItemManager.addElement(o);o.adjustPolygon(this._spawnPoints.getRandomSpawnPoint(e,i,s,r,n,a),0)}throw Error("Failed to spawn all the keys")}spawn(t,e,i,s,r){const n=ie.create(t,this._spawnPoints.getSpawnPoint(e,i,s,r),0);this._collectibleItemManager.addElement(n)}}se.MAX_AMMO_SPAWN_INTERVAL=6e4,se.RESPAWN_TRYS_AMOUNT=5;class re{constructor(t,e,i){this._spawnPoints=[],this._spawnGridsLinesAmount=e,this._spawnGridsColumnsAmount=i,this.calcSpawnPoints(t)}calcSpawnPoints(e){const i=new o(e.x+t.WALL_WIDTH[0],e.y+t.WALL_HEIGHT[0]+t.WALL_WIDTH[0]/2),s=t.WALL_WIDTH[0]+t.WALL_WIDTH[1],r=t.WALL_WIDTH[0]+t.WALL_HEIGHT[1];for(let t=0;t<this._spawnGridsLinesAmount;t++){this._spawnPoints[t]=[];for(let e=0;e<this._spawnGridsColumnsAmount;e++)this._spawnPoints[t][e]=new o(i.x+s*e,i.y+r*t)}}getRandomSpawnPoint(t,e,i=0,s=this._spawnGridsLinesAmount-1,r=0,n=this._spawnGridsColumnsAmount-1){const a=R(i,s),l=R(r,n),h=this._spawnPoints[a][l];return new o(h.x-t/2,h.y-e/2)}getSpawnPoint(t,e,i,s){const r=this._spawnPoints[i][s];return new o(r.x-t/2,r.y-e/2)}}class ne{constructor(t,e,i){this._spawnPoints=t,this._collisionChecker=e,this._tankElementAdder=i}}class ae{constructor(){}static get CONTROL_1(){return{forwardKey:87,backwardKey:83,hullClockwiseKey:68,hullCounterClockwiseKey:65,turretClockwiseKey:86,turretCounterClockwiseKey:67,shootKey:66}}static get CONTROL_2(){return{forwardKey:38,backwardKey:40,hullClockwiseKey:39,hullCounterClockwiseKey:37,turretClockwiseKey:190,turretCounterClockwiseKey:188,shootKey:191}}static start(e){const i=ae.createInfoPanel(e);t.setResolutionResizeCoeff(e.width,e.height);const s={width:e.width,height:e.height};ae.createMaze1(e.getContext("2d"),s,i)}static createMaze1(e,i,s){let r=new o(t.resizeX(103),t.resizeY(355)),n={color:0,hullNum:0,trackNum:0,turretNum:0,weaponNum:0,control:ae.CONTROL_1};const a=new lt(r,4.71,n);r=new o(t.resizeX(1750),t.resizeY(850)),n={color:1,hullNum:0,trackNum:0,turretNum:0,weaponNum:0,control:ae.CONTROL_2};const l=new lt(r,4.71,n);ae.createMaze(e,i,1,2,a,l,s,dt.createMazeLvl1,ae.createMaze2)}static createMaze2(e,i,s){let r=new o(t.resizeX(100),t.resizeY(845)),n={color:0,hullNum:0,trackNum:0,turretNum:0,weaponNum:0,control:ae.CONTROL_1};const a=new lt(r,0,n);r=new o(t.resizeX(1585),t.resizeY(845)),n={color:1,hullNum:0,trackNum:0,turretNum:0,weaponNum:0,control:ae.CONTROL_2};const l=new lt(r,0,n);ae.createMaze(e,i,1,2,a,l,s,dt.createMazeLvl2,ae.createMaze3)}static createMaze3(e,i,s){let r=new o(t.resizeX(100),t.resizeY(845)),n={color:0,hullNum:0,trackNum:0,turretNum:0,weaponNum:0,control:ae.CONTROL_1};const a=new lt(r,0,n);r=new o(t.resizeX(1750),t.resizeY(845)),n={color:1,hullNum:0,trackNum:0,turretNum:0,weaponNum:0,control:ae.CONTROL_2};const l=new lt(r,3.14,n);ae.createMaze(e,i,1,2,a,l,s,dt.createMazeLvl3,ae.endGame)}static endGame(t,e,i){const s=new Image(e.width,e.height);s.src="src/img/cat.jpg",s.onload=()=>{t.drawImage(s,0,0,e.width,e.height),i.textContent="The attacker wins"}}static createMaze(t,e,i,s,r,n,a,o,l){const{wallsArray:h,point:c}=ut.createWallsAroundPerimeter(17,7,s,e),_=new re(c,5,11),u=new oe(r,n,l,a,t,e,_),d=u.gameMaster;d.setBackgroundMaterial(i),d.addTankElements(r,n),d.addWallElements(h),d.addWallElements(o(s,c));const m=new se(_,d.itemCollisionManager);ae.addKeys(m),d.addExecutioners(new le(u),m)}static addKeys(e){for(let i=0;i<ae.AMOUNT_OF_KEYS;i++)e.randomSpawn(a.key,t.KEY_SIZE,t.KEY_SIZE,0,4,Math.ceil(5.5),10)}static createInfoPanel(t){t.style.top=`${ae.PANEL_HEIGHT}%`,t.style.height=100-ae.PANEL_HEIGHT+"%";const e=document.createElement("div");e.id="info-panel",e.style.height=`${ae.PANEL_HEIGHT}%`,document.body.appendChild(e);const i=document.createElement("div");return i.id="key-count",e.appendChild(i),i}}ae.AMOUNT_OF_KEYS=3,ae.PANEL_HEIGHT=5;class oe{constructor(t,e,i,s,r,n,a){this._score=0,this._attacker=t,this._defender=e,this._panelInfo=s,this._gameMaster=new qt(r,n,this),this._nextMaze=i,this._tankSpawnManager=new ne(a,this._gameMaster.modelCollisionManager.collisionChecker,this._gameMaster)}addBonus(t,e){switch(e){case a.kill:return!0;case a.key:if(t===this._attacker)return this._score++,this.endGameConditions()&&this.processPostGameActions(),!0;break;case a.bulGrenade:case a.bulHeavy:case a.bulLight:case a.bulMedium:case a.bulSniper:if(t instanceof lt)return t.model.takeBullet(e),!0}return!1}endGameConditions(){return 3===this._score}processPostGameActions(){this._gameMaster.removeEventListeners(),this._gameMaster.finishGame(),this._nextMaze(this._gameMaster.ctx,this._gameMaster.size,this.panelInfo)}get score(){return this._score}get panelInfo(){return this._panelInfo}get gameMaster(){return this._gameMaster}}class le{constructor(t){this._lastScore=1/0,this._rulesManager=t}handle(){this._lastScore!==this._rulesManager.score&&(this._lastScore=this._rulesManager.score,this.updatePanel())}updatePanel(){this._rulesManager.panelInfo.textContent=`Amount of Keys: ${this._lastScore}`}}const he=document.querySelector("#canvas");he.width=window.screen.width,he.height=window.screen.height,class{constructor(){}static start(t,e){if(0===t)ae.start(e)}}.start(0,he),he.addEventListener("click",(function(e){const i=e.clientX-he.getBoundingClientRect().left,s=e.clientY-he.getBoundingClientRect().top;console.log(`x = ${t.undoResizeX(i)}px, y = ${t.undoResizeY(s)}px`)}))})();